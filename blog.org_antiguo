#+TITLE: uGeek Blog 
#+LINK: https://ugeek.github.io/blog
#+DESCRIPTION: Blog de Tecnología, Android, GNU Linux, Servidores, y mucho más. Blog vinculado al Blog del Podcast de uGeek
#+KEYWORDS: GNU, linux, Raspberry, android, domótica 
#+AUTHOR: Angel
#+LANGUAGE: es
#+STARTUP: logdone
#+STARTUP: inlineimages
#+OPTIONS: timestamp:nil html-postamble:nil toc:t num:nil ^:nil toc:nil title:nil author:nil date:nil created:nil' 
#+startup: hideblocks
#+HTML_HEAD: <div id="logo"><a href="https://ugeek.github.io"><img src="__icon/ugeek.png" border="0"  width="90" height="90" alt="uGeek"></a></div>
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="__css/stylesheet.css" /><link rel="alternate" type="application/rss+xml" href="https://ugeek.github.io/feed.xml" title="uGeek - Blog de Tecnología">   
#+HTML_HEAD:  
#+html: <link href='http://fonts.googleapis.com/css?family=Lato' rel='stylesheet' type='text/css'/>
#+html: <div id="name"><a href="https://ugeek.github.io/"><tt>Blog del Podcast</tt></div></a>
#+html: <div id="icon"><a href="http://feeds.feedburner.com/uGeek" title="rss" alt="rss"><img src="__icon/podcast.png"  width="25" height="25" alt="podcast"></a>&nbsp;&nbsp;<a href="http://feeds.feedburner.com/uGeekBlog" alt="rss"><img src="__icon/rss.png"  width="25" height="25"></a>&nbsp;&nbsp;<a href="https://github.com/ugeek"><img src="__icon/github.png"  width="25" height="25" alt="GitHub"></a>&nbsp;&nbsp;<a href="https://twitter.com/ugeekpodcast"><img src="__icon/twitter.png"  width="25" height="25" alt="Twitter"></a>&nbsp;&nbsp;<a href="https://t.me/uGeek"><img src="__icon/telegram.png"  width="25" height="25" alt="Telegram"></a></div>
#+html: <div id="menu"><a href="https://ugeek.github.io/blog/list.html"><tt>Artículos</tt></a>&nbsp;&nbsp;<a href="https://ugeek.github.io/list.html"><tt>Podcasts</tt></a>&nbsp;&nbsp;<a href="https://ugeek.github.io/tags.html"><tt>Tags</tt></a></div>
#  #+html: <div id="ugeek"><a href="https://ugeek.github.io" title="uGeek"><tt>uGeek</tt></a></div>
#+html:<br><br><br><br><br><br><br><br><br><br>                                                                                             




* Nginx para Raspberry. Docker de LinuxServer

El tamaño de la imagen es de 103MB, pero en este caso está mas justificado, ya que viene con un certificado generado automáticamente al azahar.
#+BEGIN_SRC 
docker create \
--name=nginx \
-v $HOME/docker/nginx:/config \
-e PUID=1000  \
-p 80:80 -p 443:443 \
-e TZ=Europe/Madrid \
lsioarmhf/nginx-armhf
#+END_SRC

* Desplazar con las flechas por el Historial de la Terminal (Linuxito)



Crear o editar el archivo =.inputrc= en el $HOME de nuestro usuario:

Yo como sabéis utilizo emacs, pero podríamos utilizar vim, nano... 
=emacs .inputrc=

Dentro del mismo, agregar las siguientes líneas:
#+BEGIN_SRC 
## flecha arriba
"\e[A":history-search-backward
## flecha abajo
"\e[B":history-search-forward
#+END_SRC
- https://www.linuxito.com/2-uncategorised/1160-configurar-bash-para-que-las-flechas-de-teclado-se-comporten-como-en-csh
* Instalando Docker en mi Raspberry Pi
** Instalando snap y Docker
_Instalando snap_

=sudo apt install snapd=

_Versión estable de Docker_

=sudo snap install docker=

* Sustituir comas de un .csv por Tabulado, Barra Vertical, etc ...

El comando *sed* es un vicio y con la terminal y cualquier archivo de texto, puedes hacer maraviallas.

=sed -i 's|,|\t\t|g' archivo.csv= 

* Script para publicar

#+BEGIN_SRC 
# Copiar los html,xml y carpeta de post
cp -r *.html *.xml post/ /home/angel/git/blog/

# Subir a git
git add . ; git commit -m "nuevo post" ; git push
#+END_SRC

* Crear tu propio Feed o Rss
** Que es un Feed o rss

Es una archivo de texto plano en formato .xml, que contiene información sobre, por ejemplo, el titulo, descripción y url de una página web.
Así, sin necesidad de acceder a la página web y solo leyendo este archivo .xml, con una aplicación destinada a este fin, podremos saber si hay nuevas publicaciones. 

** Estructura

El archivo xml esta compuesto principalmente de dos bloques:
1) El contenedor global, que son las etiquetas de inicio y final, etiqueta *rss* para el formato 2.0.
2) El Canal (channel) que proporcionará los artículos o datos.(Título, descripción, url,...)

** Etiquetas Principales

El rss es el contenedor y dentro, esta el canal(channel) de distribución, compuesto por varias etiquetas, dependiendo del tipo de Feed.
#+BEGIN_SRC 
<rss version="2.0"><font></font>
<channel><font></font>
...<font></font>
</channel><font></font>
</rss>
#+END_SRC

** Detectar el feed a través de nuestro Navegador

Para que en nuestro navegador detecte que tenemos una fuente rss (RSS 2.0) en nuestro sitio, tenemos que adjuntar este código entre las etiquetas <head></head>.


Sustituir la url y título:
#+BEGIN_SRC 
<link rel="alternate" type="application/rss+xml" href="https://ugeek.gitlab.io/feed.xml" title="uGeek - Blog de Tecnología">
#+END_SRC

En el caso de disponer otro tipo de rss como RSS 0.92 o Atom, el código a añadir sería el siguiente:

#+BEGIN_SRC bash
# RSS 0.92
<link rel="alternate" type="text/xml" href="https://ugeek.gitlab.io/feed.xml" title="uGeek - Blog de Tecnología"/>

# Atom
<link rel="alternate" type="application/atom+xml" href="https://ugeek.gitlab.io/feed.xml" title="uGeek - Blog de Tecnología" />
#+END_SRC

** test

Bienvenido al Blog de uGeek. Aquí encontraras tutoriales y notas que voy tomando en el proceso de aprendizaje de todo aquello que os explico en el [[https://ugeek.github.io][Podcast]]. He decidido separar el blog, porque era muy complejo localizar los tutoriales entre tanto Podcast y ahora, en este blog, quedará todo bien clasificado.

** google analitycs

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-131560140-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-131560140-1');
</script>

* Transforma tus Documentos escaneados a Texto

La nueva versión de sistema OCR Tesseract 4 es uno de los mejores OCR de código abierto y nos va permitir poder extraer el texto de documentos escaneados, pdf, etc...

Tesseract 4 agrega un nuevo motor de OCR basado en redes neuronales LSTM. Y es de Google.

Para los idiomas basados ​​en el latín, los datos del modelo existente proporcionados se han capacitado en aproximadamente 400000 líneas de texto que abarcan aproximadamente 4500 fuentes .

** Instalación

Super simple!!! está en los repositorios. En Ubuntu 18.04, contamos con la versión tesseract 4.0.0-beta.1
#+BEGIN_SRC 
sudo apt install tesseract-ocr
sudo apt install libtesseract-dev
#+END_SRC
Comprobar la versión:
=tesseract --version=

Tesseract 4 tiene dos motores OCR: 
1) Motor Legacy Tesseract
2) Motor LSTM. Hay cuatro modos de operación elegidos usando la =--oem= opción. 
- 0 motor de legado solamente.
- 1 Motor de redes neuronales LSTM solamente.
- 2 motores Legacy + LSTM.
- 3 Predeterminado, basado en lo que está disponible.

** Instalando los Idiomas

Tesseract tiene mas de 100 Idiomas, así que para el correcto funcionamiento, necesitamos instalar el paquete del idioma que utilizaremos. Para instalar el diccionario en castellano:
=sudo apt install tesseract-ocr-spa=

Si quisieras instalar todos los idiomas:
=sudo apt install tesseract-ocr-spa=

Otros idiomas como Catalán, Ingles, Frances,...
=sudo apt-get install tesseract-ocr-cat tesseract-ocr-eng tesseract-ocr-fra=

** Vamos a extraer el Texto

Tesseract puede extraer el contenido de archivos de imagen más comunes como jpg, png, tiff...

Ver el texto en la terminal:
=tesseract imagen.jpg stdout=

=tesseract image.jpg stdout -l spa --oem 1=
Enviar el contenido de la imágen a un archivo de texto:
=tesseract imagen.jpg imagen=
No utilices la extiensión =.txt= en el comando, ya que Tesseract lo escribe esta extensión por defecto.

** Procesar la imagen para Mejorar la Precisión de OCR

Por varios motivos, como el color de fondo del documento, tamaño de letra, etc... Tesseract no consigue leer correctamente el contenido de la imagen. Para mejorar esto, instalaremos Imagemagick. 

* Instalando Imagemagick

Imagemagick es una herramienta para terminal que y nos permite recortar, redimensionar, cambiar color... de imágenes.
=sudo apt install imagemagick=

** Redimensionar la Imagen:

Apliando la imagen, aumentaremos el tamaño del texto.
El porcentaje indica el tanto por ciento "%" de ampliación. 100% sería el tamaño actual.
=convert -resize 150% archivo_entrada.jpg archivo_salida.jpg=

** Escala Grises

El color con el texto, puede confundir a Tesseract. Utilicemos la escala de grises.
=convert archivo_entrada.jpg -type Grayscale archivo_salida.jpg=

** Binarizar

Tras este procesado, podemos binarizar indicando drásticamente que convierta los pixels a blanco y negro. Podemos variar el umbral mediante el porcentaje "%" nuevamente.

=convert archivo_entrada.jpg -threshold 55% archivo_salida.jpg=



- [[https://www.howtoforge.com/tutorial/tesseract-ocr-installation-and-usage-on-ubuntu-16-04/][Fuente]]

* Twitter para Terminal
** Instalación

=sudo pip3 install rainbowstream=

** Iniciando

Iniciamos 
=rainbowstream=

- Se abrirá el navegador y nos mostrará el pin para introducirlo en la terminal.
- Una vez hecho esto, ya podemos utilizar twitter desde la terminal.

** Uso

- Mostrar los últimos 10 Tweets =home 10=
- Twittear, introducimos *t* el tweet y enter. ejem: =t esto es un tweet=



| h | ayuda                                   |
| p | Para pausar la transmisión de twitter   |
| r | Para reanudar la transmisión de twitter |
| c | Borrar pantalla                         |
| v | Versión para la transmisión de twitter  |
| q | salir                                   |

theme                                                           
theme Name-of-theme                                             
notification                                                    
whois @testuserlinux                                            
mentions                                                        
view @ testuserlinux                                            
s string                                                        
inbox                                                           
fl @twitter_user                                                
ufl @twitter_user                                               
block @twitter_user                                             
unblock @twitter_user                                           
report @twitter_user                                            
List home                                                       

- https://linuxconfig.org/tweet-from-the-linux-command-line-with-rainbow-stream
- https://linoxide.com/linux-how-to/install-rainbow-stream-commandline-twitter-client-linux/

- [[https://rainbowstream.readthedocs.io/en/latest/][rainbowstream]]

Como me gusta twitter

* snap
** Actualizar todos los paquetes
** Actualización de un paquete
Vamos a utilizar de ejemplo syncthing:
=sudo snap refresh syncthing=
** Ver aplicaciones instaladas
=snap list=
** Desinstalar un paquete snap
=sudo snap remove paquete=

** Cambios recientes en el sistema:
=snap changes=

** Ayuda
=snap help=
* Instalando Syncthing por snap

=sudo snap install syncthing=

* ============
 

* IPTV
** Canales
_Noticias_:
- [[http://f24hls-i.akamaihd.net/hls/live/221193/F24_EN_LO_HLS/master_900.m3u8][France 24]]
- 

* Synapse 

De tanto cambiar de distros y entornos gráficos, llega un momento que no localizo donde están las aplicaciones.
También me ocurre, a veces, que estoy trabajando con un determinado archivo y no recuerdo en que ubicación de mi pc lo guardé.
Cuando apareció Unity de Ubuntu, me pareció un gran descubrimiento, porque solucinaba muchos de estos problemas, pero tras la versión
12.04, que necesitaba más potencia a nivel gráfico, dependiendo de la tarjeta gráfica, utilizar este lanzador, resultaba un poco lento y
eso me hizo buscar alternativas.

*Synapse fue la solución*

Un lanzador ultra rápido que busca y pone a tu disposición, al instante, tanto aplicaciones, fotos, audios, videos, ubicaciones dentro de
nuestro ordenador y hasta busquedas en internet.

Synapse va aprendiendo de nuestro comportamiento y con solo marcar la primera inicial del nombre de aplicación o archivo, nos
previlualizará el resultado para que accedamos muy rápido y hacernos más productivos.

Desplazando con las flechas de izquierda a derecha, podremos seleccionar entre los diversos tipos de categorias y de arriba a abajo,
dependiendo de nuestro uso, los resultados por importancia de estos.

Por defecto, el lanzador se inicia pulsando las teclas Ctrl+espacio, pero podemos configurar la combinación de teclas que nosotros
deseemos.

Synapse como os explicaba, funciona en cualquier entorno gráfico, actualmente lo tengo instalado en LXDE, Mate (Ubuntu) y Gnome Shell
(Antergos).

Dadle una oportunidad y no podreis pasar sin ella.

Synapse está en los repositorios y tiendas con interfaz gráfica de Ubuntu, Antergos…
De todas maneras, también podéis instalarla desde la terminal escribiendo:

Antergos

=sudo pacman -S synapse=

=sudo apt install synapse=

Ubuntu
* Instalar Ruby y Jekyll *adjuntar información de mis notas*

Voy a explicar como instalar un blog de Jekyll para poder ejecutarlo en local y posteriormente, si lo desamos, subirlo a GitHub. Es muy
importante trabajar en local y no hacerlo desde la interfaz web de GitHub, ya que el proceso de publicación, modificaciones…, es mucho mas
lento y conduce a errores que nos van a crear muchos quebraderos de cabeza.

Decir que me remito a Antergos y Ubuntu, pero en realidad es como decir derivadas de Arch Linux o Debian.

Cada comando, irá separado por “/”, que separa a la izquierda el comando de Antergos y a la derecha el de Ubuntu.

Antergos / Ubuntu


** Instalamos ruby

=sudo pacman -S ruby /  sudo apt install ruby=

Instalamos Jekyll

=sudo pacman -S jekyll / sudo apt install jekyll=

Ahora vamos a instalar un par de librerías de ruby

=gem install jekyll bundler / sudo gem install jekyll bundler=

** Solo en Antergos
Ahora te tienes que ir al fichero *~/.bashrc* y pegar esta línea al final del fichero:

   #+begin_src 
PATH="$(ruby -e 'print Gem.user_dir')/bin:$PATH"
   #+end_src
Guarda y reinicia la terminal.

** Ejecutar el Blog en local

Ir al directorio raiz del proyecto ejecuta:

=jekyll serve=

Si da error, ejecuta para instalar esa dependencia:

=gem install jekyll-sitemap / sudo gem install jekyll-sitemap=

vuelve a ejecutar:

=jekyll serve=

Para acceder desde otro dispositivo dentro de nuestra red local, poniendo por ejemplo que el localhost o ip local de nuestro dispotivo es
192.168.1.100, ejecutar:

=jekyll serve --host 192.168.1.100=

* Crear un Blog Jekyll desde la Terminal  *adjuntar información de mis notas*

Vamos a crear un Blog Jekyll desde la terminal, teniendo en cuenta que previamente hemos instalado tanto Ruby como Jekyll.

Primero creamos la carpeta donde depositaremos el Blog

sudo mkdir blog

Ahora crearemos el blog por defecto en Jekyll

jekyll new blog

Si tuvieramos un blog guardado en zip, ahora lo descomprimiriamos y copiariamos:

  * indice.html, CNAME y la carpeta _posts

Ahora entramos dentro de la carpeta blog y ejecutariamos:

jekyll serve

Si funciona correctamente, ya podemos subirlo a GiHub.

------------------------------------------------------------------------------------------------------------------------------------------

Recordar que si queremos cambiar el puerto por defecto a otro (ejem: 4003), deberiamos ejecutad:

jekyll serve --ports 4003

Para poder acceder desde otro dispositivo dentro de nuestra red local, debemos especificar la ip del dispositivo (ejem:192.168.1.100):

jekyll serve --host 192.168.1.100


* Jekyll i Wordpress

  * Herramientas para crear Websites, con pros y contras para ambos.
   
    WordPress
   
  * WordPress https://wordpress.org/ (No Wordpress.com claro…)

** Filosofía

    La filosofía de WordPress apuesta decididamente por la elegancia, la sencillez y las recomendaciones del [[https://es.wikipedia.org/wiki/W3C][W3C]] pero depende siempre de
    la plantilla a usar. TwentyTen, por ejemplo, es una plantilla predeterminada y que es válida como (X)HTML Tradicional y CSS.
   
    — Wikipedia https://es.wikipedia.org/wiki/WordPress
   
    Concepto
   
    WordPress es un [[https://es.wikipedia.org/wiki/Sistema_de_gesti%25C3%25B3n_de_contenidos][sistema de gestión de contenidos]] o [[https://es.wikipedia.org/wiki/Sistema_de_gesti%25C3%25B3n_de_contenidos][CMS]] (por sus siglas en inglés, Content Management System) enfocado a la creación de
    cualquier tipo de sitio web. Originalmente alcanzó una gran relevancia usado para la creación de [[https://es.wikipedia.org/wiki/Blogs][blogs]], para convertirse con el tiempo
    en una de las principales herramientas para la creación de páginas web comerciales.
   
    Eligió el nombre WordPress por sugerencia de su amiga [[http://bigpinkcookie.com/][Christine Selleck]].
   
    — Wikipedia https://es.wikipedia.org/wiki/WordPress
   
    Licencia
   
      + Es software libre
      + GPL https://es.wikipedia.org/wiki/GNU_General_Public_License

** Creador

    Su fundador es [[https://es.wikipedia.org/wiki/Matt_Mullenweg][Matt Mullenweg]], ([[https://es.wikipedia.org/wiki/Houston][Houston]], [[https://es.wikipedia.org/wiki/Texas][Texas]], [[https://es.wikipedia.org/wiki/11_de_enero][11 de enero]] de [[https://es.wikipedia.org/wiki/1984][1984]]). WordPress fue creado a partir del desaparecido b2/cafelog y se
    ha convertido en el [[https://es.wikipedia.org/wiki/CMS][CMS]] más popular de la [[https://es.wikipedia.org/wiki/Blogosfera][blogosfera]] y en el más popular con respecto a cualquier otro [[https://es.wikipedia.org/wiki/CMS][CMS]] de uso general.[[https://es.wikipedia.org/wiki/WordPress#cite_note-2][2]] [[https://es.wikipedia.org/wiki/WordPress#cite_note-3][3]]
   
    Las causas de su enorme crecimiento son, entre otras, su licencia, su facilidad de uso y sus características como gestor de
    contenidos.
   
    — Wikipedia https://es.wikipedia.org/wiki/WordPress
   
** Desarrollo

  * Ha sido desarrollado en el lenguaje [[https://es.wikipedia.org/wiki/PHP][PHP]] para entornos que ejecuten [[https://es.wikipedia.org/wiki/MySQL][MySQL]] y [[https://es.wikipedia.org/wiki/Servidor_HTTP_Apache][Apache]].
   
    Estructura
   
  * WordPress, en principio, es un sistema de publicación web basado en entradas ordenadas por fecha; las entradas corresponden a una o
    más categorías o taxonomías. Además, cuenta con un administrador de páginas estáticas no cronológicas.
  * La estructura y diseño visual del sitio depende de un sistema de plantillas independiente del contenido, que pueden tener varias
    opciones de personalización dependiendo de su autor.
  * Bloques con funciones específicas por medio de complementos cuya publicación se realiza por medio de [[https://es.wikipedia.org/wiki/Widget][widgets]].
  * Separa el contenido y el diseño en [[https://es.wikipedia.org/wiki/XHTML][XHTML]] y [[https://es.wikipedia.org/wiki/Hojas_de_estilo_en_cascada][CSS]]; aunque, como se ha dicho, depende de la plantilla que se esté usando. No obstante, el
    código que se intenta generar en las entradas apuesta por esta característica forzando (si así se elige) un marcado correcto.
  * La gestión y ejecución corre a cargo del sistema de administración con los complementos y widgets que usan las plantillas.

** Funcionalidades

  * Fácil instalación, actualización y personalización.
  * Actualización automática del sistema implementada en la versión 2.7.
  * Múltiples autores o usuarios, junto con sus roles o perfiles que establecen distintos niveles de permisos (desde la versión 2.0).
  * Sitios con varios blogs, multisite (a partir de la versión 1.6).
  * Capacidad de crear páginas estáticas (a partir de la versión 1.5).
  * Permite ordenar artículos[[https://es.wikipedia.org/wiki/WordPress#cite_note-8][8]] y páginas estáticas en categorías, subcategorías y etiquetas.
  * Cuatro estados por entrada: Publicado, Borrador, Esperando revisión (nuevo en WordPress 2.3) y Privado (solo usuarios registrados),
    además de uno adicional: Protegido con contraseña.
  * Editor [[https://es.wikipedia.org/wiki/WYSIWYG][WYSIWYG]] (por sus siglas en inglés, «lo que ves es lo que tienes»), desde la versión 2.0.
  * Publicación mediante correo electrónico.
  * Importación desde Blogger, Blogware, Dotclear, Greymatter, Livejournal, Movable Type y Typepad, Textpattern y desde cualquier fuente 
    [[https://es.wikipedia.org/wiki/RSS][RSS]]. Se está trabajando para poder importar desde pMachine y Nucleus además de la importación a través de scripts o directamente de
    base de datos.
  * Guardado automático temporizado del artículo como borrador (a partir de la versión 2.2).
  * Permite comentarios y herramientas de comunicación entre blogs ([[https://es.wikipedia.org/wiki/Trackback][Trackback]], [[https://es.wikipedia.org/wiki/Pingback][Pingback]], etc).
  * Admite el uso de permalinks (enlaces permanentes y fáciles de recordar) mediante mod_rewrite.
  * Distribución de los artículos mediante RDF, [[https://es.wikipedia.org/wiki/RSS_%2528formato%2529][RSS]] 0.92, RSS 2.0 y [[https://es.wikipedia.org/wiki/Atom_%2528formato_de_redifusi%25C3%25B3n%2529][Atom]] 1.0.
  * Distribución de los comentarios (mediante RSS 2.0 y ATOM 1.0).
  * Gestión y distribución de enlaces.
  * Subida y gestión de datos adjuntos y archivos multimedia.
  * Admite complementos (versión 1.5).
  * Admite plantillas y widgets.
  * Búsqueda integrada en entradas y páginas estáticas, y widget predeterminado para la búsqueda integrada de Google desde la versión 2.5.
    [[https://es.wikipedia.org/wiki/WordPress#cite_note-9][9]]
  * Integración:
      + [[https://es.wikipedia.org/w/index.php?title=BbPress&action=edit&redlink=1][bbPress]], sistema de foros de los mismos creadores, se integra automáticamente con WordPress.
      + Integración con el foro Vanilla de Lussumo [[http://web.archive.org/web/http://lussumo.com/docs/doku.php?id=vanilla:integration:wordpress][factible]], al menos hasta la versión 2.2 no inclusive.
  * Previsualización
  * Versionado de artículos
   
**     Multisite
   
  * WordPress admite un sitio por instalación, pero gracias a extender el sitio por medio de complementos específicos es fácil administrar
    y configurar múltiples sitios desde una sola instalación. Esta característica está implementada en el núcleo de WordPress desde la
    versión 3.0.5
   
    Características
   
      + Plugins
      + Más expuesto
      + Más “pesado”
      + Más fácil
      + Posibilidad de alojarlo en tu server con https
      + 25% de las páginas de todo el mundo están en WordPress
      + Podcasts: “Wordpress Diario”, “Potencia Pro”, “Wordpres Radio” (Boluda
      + MySQL
      + Webs Dinámicas (Capacidad para hacer casi lo que quieras, tiendas, catálogos,etc..)


** Jekyll

  * [[https://jekyllrb.com/][Jekyll]]
   
    Licencia
   
  * Es software libre
  * MIT License https://en.wikipedia.org/wiki/MIT_License
   
    Filosofía
   
        Hace lo que le pides que haga, ni más ni menos. No trata de burlar a los usuarios haciendo suposiciones audaces, ni les carga con
        complejidad y configuración innecesarias. En pocas palabras, Jekyll se sale de su camino y te permite concentrarte en lo que
        realmente importa: su contenido.
       
Es el blog hacker por excelencia por su flexibilidad.

Creador

  * Creado por [[https://en.wikipedia.org/wiki/Tom_Preston-Werner][Tom Preston-Wener]] cofundador y Ceo de [[https://github.com/][GitHub]] en 2008. Nacido el 28 de octubre de 1979) es un [[https://en.wikipedia.org/wiki/Software_developer][software developer]], [[https://en.wikipedia.org/wiki/Inventor][inventor]] y
    [[https://en.wikipedia.org/wiki/Entrepreneur][emprendedor]]. Activo contribuidor de [[https://en.wikipedia.org/wiki/Free_software_movement][open-source development community]], en [[https://en.wikipedia.org/wiki/San_Francisco_Bay_Area][San Francisco Bay Area]], donde vive.
      + [[https://translate.google.com/translate?sl=en&tl=es&js=y&prev=_t&hl=en&ie=UTF-8&u=http%253A%252F%252Ftom.preston-werner.com%252F2008%252F11%252F17%252Fblogging-like-a-hacker.html&edit-text=&act=url][Artículo]] de Tom Preston-Wener presentando Jekyll
       
        Características
       
  * Texto plano, sin Bases de Datos
  * [[https://en.wikipedia.org/wiki/Markdown][MarkDown]] y [[https://en.wikipedia.org/wiki/Textile_(markup_language)][Textitle]] principalmente y html
  * Simple la edición en texto plano, se puede editar con Vim, Emacs, Gedit, TextEdit, Notepad, etc.
  * Aproximado 1,5 Mb de RAM
  * Pinta el código mediante rouge antes lo pintaba con pygments, de esta forma al marcar el código reconoce la sintaxis de Python, Ruby,
    Bash, etc.
   
**     Flujo de trabajo
   
  * Muy fácil instalación, pero requiere un mínimo de conocimientos sobre la terminal, sistema de instalación de Ruby y sus gemas.
  * Posibilidad de realizar tags, colecciones.
  * Se escribe en Markdown pero posibilidad de incrustar html.
  * Colaboración fácil, mediante GitHub, necesidad de conocer Git mínimamente.
  * Ultra-Rápido ya que renderiza desde texto plano, una vez renderizado es texto en .html
  * Webs Estáticas (google analytics, añadir comentarios, …)
  * Van apareciendo plugins pero siendo una web mas estatica, dentro de porder modificar todo
   
**     Aprendizaje
   
  * Curva de aprendizaje relativamente rápida, dependiendo de conocimientos previos
  * En menos de 1 minuto construyes el blog básico
   
    Hosting
   
  * GitHub Pages (Crear tu web gratis y sin publicidad)
  * No está tan expuesto pues es texto plano
  * Posibilidad de trabajar en https y en ssh
   
**     Local
   
  * Servidor local para previsualizar y probar código, antes de subir.

=jekyll serve=

  * Ventajas de Git, versionado
   
    Lenguaje
   
      + Toda la potencia de Ruby
      + Utiliza un lenguaje interno de templates: Liquid
       
        Componentes
       
=jekyll new myblog=

Esto creará un directorio llamado myblog/ donde se encuentran todos los archivos necesarios para crear nuestro blog.

  * _includes/
  * _layouts/
  * _posts/
  * _sass/
  * css/
  * _config.yml
  * about.md
  * feed.xml
  * index.html

_config.yml:
Archivo de configuración.

_includes/:
Directorio, contiene fragmentos de código reutilizables para incluir en nuestros templates y posts (footer.html o header.html).

_layouts/:
Directorio contiene los templates necesarios para mostrar nuestras páginas y posts.

_posts/:
Directorio donde se guardan los posts, organizados por fechas con formato inverso y escritos markdown.

_draft/:
Directorio de borradores.

Estructura de un post
#+begin_src 
 ---
 layout: post
 title: Título del post
 date:  dc 03 mai 2017 19:30:33 CEST
 description: Archivar
 keywords: archive
 coments: true
 ---

#+end_src
A partir de aquí empieza en post en Markdown


*** Conclusiones

Wordpress

  * Posibilidad de autenticación en dos pasos
  * Muy fácil de levantar
  * Host gratuito
  * Extramadamente fácil de cambiar los themes
  * Comunidad enorme, mucha documentación
  * Expuesto, se conoce la estructura
  * Curva de aprendizaje rápida
   
    Jekyll
   
  * Más seguro, no hay nada que hackear, si a caso el host, pues todo es texto plano que el navegador interpreta
  * Posibilidad de activar la autenticación en dos pasos en GitHub
  * Más rápido, posibilidad de plugins, como está generado los plugins no influyen en el rendimiento
  * Flexibilidad y personalización extrema
  * Curva de aprendizaje más lenta, para cambiar cosas hay que aprender la lógica de Liquid primero


  * [[https://www.atareao.es/apps/utext-un-editor-de-texto-markdown-para-ubuntu/][uText app de Markdown]]
   
  * [[https://ugeek.github.io/podcasts/][Reproductor web de podcasts Linux desarrollada por Lorenzo - atareao.es]]
   
  * [[http://inclusa.github.io/][Web de Alfons]]
* Crear Docker

#+BEGIN_SRC 
FROM arm32v7/debian:latest                                                                                                    
MAINTAINER angel <ugeekpodcast@gmail.com>                                                                                     
                                                                                                                              
RUN apt-get -y update; \                                                                                                      
    apt-get -y upgrade; \                                                                                                     
    apt-get -y install apt-utils \                                                                                            
    ;                                                                                                                
                                                                                                                              
VOLUME /root
VOLUME ~/.config/syncthing/                                                                                                                  
                                                                                                                              
ENTRYPOINT syncthing && /bin/bash                                                                                             
CMD ["bash"]                    

#+END_SRC
** Buscar entre Cabeceras
Tomar muchas notas, es muy sencillo, lo complicado es después encontrarlas. Cuando decides el crear un único archivo orgmode para tomar tus notas y este crece de forma desmesurada, empiezas a tener problemas cuando quieres localizar notas que sabes que has tomado, pero mediante una búsqueda sencilla por palabras, aparecen cientos de resultados.

Lo ideal sería poder buscar palabras solo en la cabeceras y no a lo largo del orgmode. En este [[https://mentat.za.net/blog/2016/12/15/org-mode-header-search/][Post de https://mentat.za.net]], explica como hacer búsqueda solo en las cabecera de primer nivel. Yo, tal como tengo estructuradas mis notas, necesitaba que buscara en todas las cabeceras. Así que he hecho una pequeña modificación al código y aquí os explico el resultado.

*** Búsqueda entre cabeceras

Pensé en replicar tantas veces como fuera necesario, la línea '(setq unread-command-events (listify-key-sequence "^* "))', e ir añadiendo Cabeceras, pero solo me ha bastado una, como aparece en esta cajetilla de código, para que entienda emacs que debe buscar en todas las Cabeceras. No me parece que sea una forma correcta, pero... Funciona!!!!

Añade en *init.es* o *.emacs*, las siguientes líneas:
#+begin_src 
(defun stefan/isearch-heading ()
  (interactive)
  (setq unread-command-events (listify-key-sequence "^* "))
  (setq unread-command-events (listify-key-sequence "^** "))
  (isearch-mode t t nil t))


(defun org-mode-keys ()
  (interactive)
  (local-set-key (kbd "C-c h") 'stefan/isearch-heading)
)
(add-hook 'org-mode-hook 'org-mode-keys)
#+end_src
*** Hacer Búsquedas
Para buscar una palabra que estará en cualquiera de las cabeceras, pulsaremos las teclas *C-c h*. Recuerda que podrás personalizar el atajo que desees cambiando este en el código. 

Una vez hecha la primera búsqueda, si tienes mas cabeceras con la misma palabra que deseas buscar, debes de pulsar *C-s* todo el rato, ara ir avanzando a lo largo de las coincidencias

*** Buscar en Cabeceras de Primer Nivel
Código para solo Buscar en cabeceras de primer nivel:
#+begin_src 
(defun stefan/isearch-heading ()
  (interactive)
  (setq unread-command-events (listify-key-sequence "^* "))
  (isearch-mode t t nil t))


(defun org-mode-keys ()
  (interactive)
  (local-set-key (kbd "C-c h") 'stefan/isearch-heading)
)
(add-hook 'org-mode-hook 'org-mode-keys)
#+end_src

* Resilio

resilio 

Ya aprendimos a instalar Syncthing, ahora toca hacer lo propio con la opción privativa Resilio.

Ubuntu, Raspbian y dereivadas de debian

1- Añadimos los repositorios:

echo "deb https://linux-packages.resilio.com/resilio-sync/deb resilio-sync non-free" | sudo tee /etc/apt/sources.list.d/resilio-sync.list

2- Actualizamos el repositorio:

sudo apt update

3- Instalamos Resilio

sudo apt-get install resilio-sync

Ahora escribimos localhost:8888 y entraremos en la interfaz web de resilio.

Otras instrucciones:

systemctl stop resilio-sync
systemctl start resilio-sync
systemctl restart resilio-sync
systemctl status resilio-sync

Antergos y derivadas de Arch

1- Instalar resilio:

yaourt -S rslsync

2- Iniciamos resilio con:

rslsync

Ahora escribimos localhost:8888 y entraremos en la interfaz web de resilio.

* Crear un usb con una ISO de una distro

Publicado por Angel

usb     

Averiguamos cual es el nombre de nuestro usb o pendrive con:

lsblk

La primera parte es la iso (“nombre_de_la_iso.iso”) y la segunda, la unidad de pendrive (/dev/sdb):

sudo dd if=nombre_de_la_iso.iso of=/dev/sdb bs=4M

Esperamos y ya tendremos nuestro usb con la distro grabada y lista para ser instalada.

* Docker en Ubuntu, Antergos y derivadas en menos de 10 minutos

Instalación en Ubuntu

Agregamos clave GPG:
sudo apt-key adv --keyserver hkp://p80.pool.sks-keyservers.net:80 --recv-keys 58118E89F3A912897C070ADBF76221572C52609D

Agregamos repositorio:
sudo apt-add-repository 'deb https://apt.dockerproject.org/repo ubuntu-xenial main'

Actualizamos:
sudo apt-get update

Instalamos docker:
sudo apt-get install -y docker-engine

Docker tiene que estar iniciado y ejecutándose. Revisamos que realmente funcione:
sudo systemctl status docker

------------------------------------------------------------------------------------------------------------------------------------------

Instalación en Antergos

Instalar Docker
sudo pacman -S docker

Correr Docker
sudo systemctl start docker sudo systemctl enable docker

------------------------------------------------------------------------------------------------------------------------------------------

Instalación de Portainer
Ahora vamos a instalar Portainer. Una servicio web para gestionar nuestro containers:

Instalación:
sudo docker pull portainer/portainer sudo docker run -d -p 9000:9000 -v /var/run/docker.sock:/var/run/docker.sock portainer/portainer

Ahora escribimos en nuestro navegador:
localhost:9000

Ponemos una contraseña de administrador para gestionar el servicio.

Señalamos la primera opción de las 2 que aparecen para conectarnos y listo…

------------------------------------------------------------------------------------------------------------------------------------------

Instalación de Containers

Instalar Dockers desde Hub de Docker

vamos a: [[https://hub.docker.com/search/][https://hub.docker.com/search/]]

 1. Buscamos el Nombre del Docker,lo copiamos
 2. Vamos a la sección Images de portainer y pegamos el nombre en Name
 3. Clicamos el botón que pone pull
 4. En Images aparecen todos los containers que tenemos
 5. Vamos a la sección Containers y clicamos + Add container
 6. Ponemos un nombre que queramos y en Image, el nombre de la imagen y pulsamos start

* TMUX
** Instalación

=sudo apt install tmux=

** Atajos de Teclado

|                                     | Atajo            |
|-------------------------------------+------------------|
| Dividir Horizontalmente             | C-b %            |
| Dividir Verticalmente               | C-b "            |
| Moverse entre Terminales            | C-b <up-down...> |
| Matar, Cerrar la Ventana            | C-b x            |
| Dejar tmux en segundo plano         | C-b d            |
| Volver a la sesión en segundo plano | tmux attach      |
|                                     |                  |
| listar sesiones abiertas            | tmux ls          |
|                                     |                  |

** Archivo de Configuración

Por defecto, tmux va a buscar el archivo de configuración a */etc/tmux.conf*, sino irá a */tmux.conf*

man tmux) will tell you the exact location, just have a look at documentation for the -f

[[https://gist.github.com/jesusangelm/8113117][Repositorio GitHub compartido de archivo de conf. de tmux]]

#+BEGIN_SRC 
#configs para Tmux
 
#shell por defecto
#set -g default-command /bin/zsh
#set -g default-shell /bin/zsh
 
#tecla de prefijo de Tmux cambiada similar a Screen: Ctrl-a
#de Ctrl-b a Ctrl-a
set -g prefix C-a
 
#libera el prefijo original de Tmux Ctrl-b
unbind C-b
 
#configuracion del retraso entre el prefijo y el comando
set -sg escape-time 1
 
#comienza numerando las ventanas desde el 1
set -g base-index 1
 
#comienza numerando los paneles desde el 1
setw -g pane-base-index 1

# re-enumera ventanas cuando se cierra una
set -g renumber-windows on
 
#recarga la configuracion de tmux y muestra un mensaje de confirmacion
bind r source-file ~/.tmux.conf \; display "~/.tmux.conf recargado!"
 
#asegura que podemos enviarle el comando Ctrl-a a otras apps
bind C-a send-prefix
 
#dividir la ventana horizontalmente
bind | split-window -h
 
#dividir la ventana verticalmente
bind - split-window -v
 
#movimiento entre los paneles como en Vim
# k
# h l
# j
#
bind h select-pane -L
bind j select-pane -D
bind k select-pane -U
bind l select-pane -R
 
#movimiento entre ventanas como en Vim
#
# prefijo + Ctrl-h prefijo + Ctrl-l
# <<<<<<<<<<<<<<<< >>>>>>>>>>>>>>>>
#
bind -r C-h select-window -t :-
bind -r C-l select-window -t :+
 
#redimencionado de paneles como las teclas de movimientos en Vim
bind -r H resize-pane -L 5
bind -r J resize-pane -D 5
bind -r K resize-pane -U 5
bind -r L resize-pane -R 5
#### me parece mas rapido redimencionar con las flechas de direccion
 
#integracion con el raton
setw -g mode-mouse on
 
#mas funciones para ejecutar con el raton
set -g mouse-select-pane on
set -g mouse-resize-pane on
set -g mouse-select-window on
 
#Compatibilidad con 256colores en la terminal
#set -g default-terminal "screen-256color"
 
#color de marcado del la ventana seleccionada
#setw -g window-status-current-bg red
 
#nombre de la sesion de tmux a la izquierda y sin []
set -g status-left "Sesion: #S"
 
#muestra hasta un maximo de 40 caracteres en nombre de la sesion
#set -g status-left-length 40
 
#hostname fecha y hora a la derecha
set -g status-right "#[fg=colour235,bg=colour252,bold] #H - %A %e %B %Y - %I:%M %p"
 
#Centrar la lista de ventanas
#set -g status-justify centre
 
#soporte de UTF-8
set -g status-utf8 on
 
#frecuencia de actualizacion de la barra de estado en segundos
set -g status-interval 2
 
#Modo Vi para Tmux
setw -g mode-keys vi
 
# portapapeles copiar
# Para copiar:
# - Presionas Ctrl A + [ para entrar en modo copiar.
# - Con el cursor mueves al inicio del contenido a copiar
# - Presionas ESPACIO para resaltar y seleccionar el texto a copiar
# - Presionas ENTER para salir
# - Presionas Ctrl A + Ctrl C para mandar el buffer de copiado de tmux al
# portapapeles
#bind C-c run "tmux save-buffer - | xclip -i -selection clipboard"
bind C-c run "tmux show-buffer | xsel -i -b"
#portapapeles pegar
#bind C-v run "tmux set-buffer -- \"$(xclip -o -selection clipboard)\"; tmux paste-buffer"
bind C-v run "tmux set-buffer -- \"$(xsel -o -b)\"; tmux paste-buffer"
 
 
#############################################################
#############################################################
 
#mejora el scroll con las teclas shift-PageUp/shift-PageDown
set -g terminal-overrides 'xterm*:smcup@:rmcup@'
 
#setw -g aggressive-resize on
 
 
#### Barra inferior similar a Powerline
if-shell 'test -z "$POWERLINE_COMMAND"' 'if-shell "which powerline-client" "set-environment -g POWERLINE_COMMAND powerline-client" "set-environment -g POWERLINE_COMMAND powerline"'
set -g status on
set -g status-utf8 on
set -g status-interval 2
set -g status-fg colour231
set -g status-bg colour234
set -g status-left-length 20
set -g status-left '#[fg=colour16,bg=colour254,bold] #S #[fg=colour254,bg=colour234,nobold]#(eval $POWERLINE_COMMAND tmux left)'
set -g status-right '#(eval $POWERLINE_COMMAND tmux right -R pane_id=`tmux display -p "#D"`)'
set -g status-right-length 150
set -g window-status-format "#[fg=colour244,bg=colour234]#I #[fg=colour240] #[default]#W "
set -g window-status-current-format "#[fg=colour234,bg=colour31]#[fg=colour117,bg=colour31] #I  #[fg=colour231,bold]#W #[fg=colour31,bg=colour234,nobold]"
set-window-option -g window-status-fg colour249
set-window-option -g window-status-activity-attr none
set-window-option -g window-status-bell-attr none
set-window-option -g window-status-activity-fg yellow
set-window-option -g window-status-bell-fg red
#+END_SRC
   


* Nextcloud 12 en Raspberry Pi 3 con MariaDB, PHP 5 y lighttp

Publicado por Angel

usb     

------------------------------------------------------------------------------------------------------------------------------------------

Instalaremos Nextcloud con MariaDB

  * Instalamos MariaDB

sudo apt install mariadb-server

Nos pedirá la contraseña

user:   root
paswd:
base:

Securizamos la instalación:

sudo mysql_secure_installation

Tras introducir la contraseña de root respondemos a las preguntas como sigue:

  * Change the root password? [Y/n] n
   
  * Remove anonymous users? [Y/n] y
   
  * Disallow root login remotely? [Y/n] y
   
  * Remove test database and access to it? [Y/n] y
   
  * Reload privilege tables now? [Y/n] y
   
Accedemos a la consola de MariaDB:

mysql -u root -p

Y ejecutamos los siguientes comandos cambiando “miusuario” y “micontraseña” al gusto: crear una base nueva mysql

mysqladmin -u root -p create NOMBRE-DE-DB

Ya tenemos lista la base de datos.

Instalamos PHP5 y el servidor lighttp

sudo apt install lighttpd php5-cgi php5-curl php5-gd php5-mysql~

  * Adaptamos para que lighttpd funcione con PHP5

sudo nano /etc/lighttpd/lighttpd.conf

Hay que ir al apartado server.modules y añadir la siguiente linea:

"mod_fastcgi",

Y al final del archivo añadimos lo siguiente:

fastcgi.server = ( ".php" => ((
                   "bin-path" => "/usr/bin/php-cgi",
                   "socket" => "/tmp/php.socket"
                )))

Ahora ya funciona php en lighttp

  * Ahora vamos a la web de [[https://nextcloud.com/install][Nextcloud]] y descargamos el archivo comprimido en:

cd /var/www/html

sudo wget https://download.nextcloud.com/server/releases/nextcloud-12.0.0.zip

sudo unzip nextcloud-12.0.0.zip

sudo rm nextcloud-12.0.0.zip

sudo chown -R www-data:www-data /var/www/html/nextcloud

Accedemos desde el navegador a nuestro servidor http://ip_de_la_raspberry.com/nextcloud/ y rellenamos todos los datos que nos pide el
instalador:

Otros comandos.

  * reiniciar lighttp

sudo service lighttpd restart


* Youtube desde la Terminal
** Instalación

Desde ubuntu:

=sudo apt install mps-youtube=


=sudo pip3 install --user mps-youtube=

Actualizar:
=sudo pip3 install mps-youtube --upgrade=

** Iniciando
=mpsyt=


- [[https://github.com/mps-youtube/mps-youtube][Fuente del Repositorio]]

* mpv

** Instalacion PPA
#+BEGIN_SRC 
sudo add-apt-repository ppa:mc3man/mpv-tests
sudo apt update
sudo apt install mpv
#+END_SRC

- [[https://mpv.io/][web]]
- [[https://github.com/mpv-player/mpv][repositorio]]
* Translate google Terminal

** Instalación
=sudo apt install translate-shell=

** Traducir una palabra
=trans palabra=
** Traducir una frase
Utilizaremos las comillas
=trans "Pon la frase entre comillas"=

** Traducción literal
=trans -brief "frase"=

** Idiomas disponibles
Google Translata tiene mas de 10 idiomas. Para poder ver abreviatura del idioma:

=trans -R=

** Traducción de un archivo de texto plano
=trans :es file:///home/angel/Documentos/t.txt=



Abrir en el navegador la página traducida: =trans url=

- https://ubunlog.com/translate-shell-traduce-terminal/
- https://www.ostechnix.com/use-google-translate-commandline-linux/
- https://github.com/soimort/translate-shell  (repositio) 
* Youtube-dl
=youtube-dl =--batch-file ="list.txt"=
* Googler

- [[https://github.com/jarun/googler][Repositorio]]
* ===========
* Convertir de Markdown a Org Mode gracias a Pandoc
:PROPERTIES:
:TITLE:    Convertir de Markdown a Org Mode gracias a Pandoc
:EXPORT_FILE_NAME: Convertir-de-markdown-a-org-Mode-gracias-a-pandoc
:DESCRIPTION: Vamos a convertir nuestros archivos Markdown a Org Mode gracias a Pandoc
:EXPORT_DATE: 2018-12-28 18:05
:CATEGORY: emacs
:TAG:      emacs,pandoc,orgmode,markdown
:IMAGE:    ./images/blog/dockeronrapi.png
:URL_AUDIO: https://anchor.fm/s/106db04/podcast/play/1672064/https%3A%2F%2Fd3ctxlq1ktw2nl.cloudfront.net%2Fstaging%2F2018-10-5%2FComo-Actualizar-tus-Dockers-9eca01f3ed771.m4a
:END:

Vamos a convertir nuestros archivos Markdown a Org Mode gracias a Pandoc. Para ello, primero necesitamos instalar Pandoc en nuestro Ubuntu:

=sudo apt install pandoc=

Ahora tenemos 2 posibilidades, transformar únicamente un archivo .md a .org, o aprovechando la magnífica gestión de los archivos Org Mode, convertir todos los archivos Markdown de una carpeta a un único archivo Org Mode.

1) Markdown a Org Mode. Ejecutamos este comando en la terminal.

=pandoc -f markdown -t org -o nuevo_archivo.org archivo_a_convertir.md=

2) Muchos archivos Markdown a un único Org Mode.

Vamos a la carpeta donde están todos los Markdown que queremos convertir y Llamamos a find vía Pandoc:

=find . -name \*.md -type f -exec pandoc  -f markdown -t org -o {}.org {} \;=

Recordar verificar que la conversión se ha hecho correctamente.

* Con Emacs, también podemos editar Markdown
:PROPERTIES:
:TITLE:    Con Emacs también podemos editar Markdown
:EXPORT_FILE_NAME: Con Emacs tambien podemos editar Markdown
:DESCRIPTION: He hablado de como crear tus archivos Org Mode mediante Emacs, pero… ¿Realmente vale la pena invertir tiempo en aprender los atajos de teclado y el funcionamiento de Emacs?
:EXPORT_DATE: 2019-01-03 18:08
:CATEGORY: emacs
:TAG:      emacs, orgmode, markdown, melpa
:END:

He hablado de como crear tus archivos Org Mode mediante Emacs, pero… ¿Realmente vale la pena invertir tiempo en aprender los atajos de teclado y el funcionamiento de Emacs?.
Por supuesto que Sí!!! Y es que Emacs no solo funciona con Org Mode, sino que con cualquier sintaxis o cosa que se os ocurra.
Hoy vamos a utilizar Emacs como editor de Markdown. Voy a dividir el post en 2 partes, resaltado de sintaxis y previsulización del documento que estamos editando con refresco instantáneo.
Resaltado de Sintaxis

Para que Emacs resalte la sintaxis de Markdown, necesitamos instalar un paquete que encontraremos en [[https://melpa.org/][Melpa]], [[https://github.com/jrblevin/markdown-mode][markdown-mode]].

** Instalación

=M-x package-install RET markdown-mode RET=

** Previsualización del documento

Para previsualizar el documento, instalaremos el paquete también de Melpa, Flymd.

Instalación:

=M-x package-install RET flymd RET=

Ahora si queremos previsualizar el documento, solo tenemos que introducir en Emacs:

=M-x flymd-flyit=

Esto, nos lanzará un archivo temporal y abrirá nuestro navegador web, para previsualizar el documento.

Por defecto se refresca en tiempo real y que podemos deshabilitar

* Kde Connect en Ubuntu, Debian, Lubuntu, Mint... y derivadas
:PROPERTIES:
:TITLE:    Kde Connect en Ubuntu...
:EXPORT_FILE_NAME: kdeconnect-en-ubuntu
:DESCRIPTION: He instalado Kde Connect en Lubuntu y Mint con el escritorio i3. Os detallo como instalarlo paso a paso
:EXPORT_DATE: 2019-01-02 18:00
:CATEGORY: bash
:TAG:      bash, terminal, i3, kdeconnect, ubuntu
:END:

He instalado Kde Connect en Lubuntu y Mint con el escritorio i3. Os detallo como instalarlo paso a paso.

Hasta el paso 3, ya estaría listo gracias a indicator-kdeconnect mediante interfaz gráfica. Pero si te animas con la terminal, llega hasta el final del post.

Recordaros que Kde Connect está tanto en Google Play como en F-Droid para Android.

** Instalación

1) Instalamos en nuestro Ubuntu

=sudo apt install kdeconnect=

Si tienes una versión superior a Ubuntu 16.04, incator-kdeconnect posiblemente estará disponible, en caso contrario, el equipo de webupd8team nos lo pone fácil.
Instala esto:

#+BEGIN_SRC 
sudo add-apt-repository ppa:webupd8team/indicator-kdeconnect
sudo apt update
sudo apt install kdeconnect indicator-kdeconnect
#+END_SRC

2) Instalamos la app en nuestro movil, tablet…

3) Buscará dentro de nuestra red local los dispositivos con Kde Connect. Empareja tu dispositivo y… Ya está!! Si quieres seguir con la terminal, sigue leyendo.

4) Vamos ha hacer el emparejamiento desde la Terminal. El comando *kdeconnect-cli - -help* nos mostrará todos los comandos disponibles.

5) Vamos a listar dispositivos disponibles en nuestra red local desde la terminal

=kdeconnect-cli -l=

La terminal nos mostrará todos los dispositivos disponibles, en mi caso, mi Xiaomi A1:
#+BEGIN_SRC 
angel@angel /usr/lib/kde4 $ kdeconnect-cli -l
        - Xiami A1: 35826fca13f58Gsu (reachable)
	    1 device found  
#+END_SRC
    
6) Vinculamos PC a mi Xiaomi A1 con nuestro:

=kdeconnect-cli -d 35826fca13f58Gsu --pair=

7) En tu movil, tablet Android, recibirás una solicitud para vincularlo.

8) Ya está condectado Kde Connect!!!

Si tienes i3 y quieres que se inicie Kde Connect por defecto, escribe estas líneas en tu archivo de configuración:
#+BEGIN_SRC 
# Autostart kdeconnect
exec --no-startup-id /usr/bin/indicator-kdeconnect
#+END_SRC

* Crear listas m3u para minidlna o vlc
:PROPERTIES:
:TITLE:    Crear listas m3u para minidlna o vlc
:EXPORT_FILE_NAME: crear-listas-m3u-para-minidlna-o-vlc
:DESCRIPTION: Un archivo *.m3u*, es un archivo de texto que contiene un listado de archivos multimedia que es muy utilizado por muchos reproductores como vlc...
:EXPORT_DATE: 2019-01-02 20:00
:CATEGORY: bash
:TAG:      bash, grep ,ls ,unix ,servidor, minidlna, multimedia
:END:

Un archivo *.m3u*, es un archivo de texto que contiene un listado de archivos multimedia que es muy utilizado por muchos reproductores como vlc.
Cuando viste el artículo de [[https://ugeek.gitlab.io/2018-12-27-minidlna.html][minidlna]], te preguntarías como hacer las playlist de este servidor. Pues ahora te explicaré como crear automáticamente listas desde tu terminal en segundos.

** Crear lista para minidlna

- Para crear la lista, no hace falta que especifiquemos la ruta del archivo en nuestro servidor, solo poniendo el nombre del mismo, minidlna buscará en su base de datos donde está este para reproducirlo.
- No importa el lugar donde esté el archivo .m3u, nuestro servidor minidlna lo agregará a su base de datos y así al grupo de playlists.

** Lista dentro de un directorio

1) Nos situamos en el directorio:
=ls -1 | grep .mp3 > lista.m3u=

*** Explicación del comando de listado

 - ls -> lista archivos dentro de la carpeta
 - -1 -> mostrar un archivo por línea
  
Después, podríamos ordenar el listado de diferente maneras, por ejemplo con comandos como *sort*.

** Lista recursiva entrando dentro de subcarpetas

=ls -1 -R | grep .mp3 > lista.m3u=

** Reproducir la lista desde nuestra terminal con vlc

=vlc lista.m3u=

* Redirigir el tráfico de una página web a otra
:PROPERTIES:
:TITLE:    Redirigir el tráfico de una página web a otra
:EXPORT_FILE_NAME: redirigir-el-trafico-de-pagina-web-a-otra
:DESCRIPTION: Hay veces que queremos redirigir el tráfico de una página a otra...
:EXPORT_DATE: 2018-12-29 18:00 2019-01-19
:CATEGORY: html
:TAG:      html,servidor
:IMAGE:    ./images/blog/dockeronrapi.png
:URL_AUDIO: https://anchor.fm/s/106db04/podcast/play/1672064/https%3A%2F%2Fd3ctxlq1ktw2nl.cloudfront.net%2Fstaging%2F2018-10-5%2FComo-Actualizar-tus-Dockers-9eca01f3ed771.m4a
:END:

Hay veces que queremos redirigir el tráfico de una página a otra. Un modo muy rápido y sencillo, sería crear un archivo .html con el siguiente código. En este ejemplo, el tiempo de espera hasta redirigir es de *3 segundos*. Podemos personalizarlo al tiempo de deseemos. 
#+BEGIN_SRC
<html>
<head>
<title>Redirigir al navegador a otra URL</title>
<META HTTP-EQUIV="REFRESH" CONTENT="3;URL=https://ugeek.gitlab.io">
</head>
<body>
Esta página te redigirá en 3 segundos a https://ugeek.gitlab.io/
</body>
</html> 
#+END_SRC

* Eliminar comentarios de nuestros script
:PROPERTIES:
:TITLE:    Eliminar comentarios de nuestros script
:EXPORT_FILE_NAME: eliminar-comentarios-de-nuestros-script
:DESCRIPTION: Es muy probable que al crear un script para entender mejor lo que estas haciendo tomes un exceso de notas...
:EXPORT_DATE: 2018-12-30 18:00
:CATEGORY: unix
:TAG:      bash, grep, sed, unix
:END:

Es muy probable que al crear un script, para entender mejor lo que estas haciendo, tomes un exceso de notas. Para eliminar estas en , *bash*, va a ser tan sencillo como hacer uso de nuestro querido *grep*:

=cat archivo.sh |  grep -v ^# > archivo_nuevo.sh=

Si además quieres eliminar también las líneas que quedaran en blanco, como expliqué en otro post, utilizaremos *sed*::

=cat archivo.sh |  grep -v ^# | sed '/^ *$/d' > archivo_nuevo.sh=

* minidlna
:PROPERTIES:
:TITLE:    minidlna
:EXPORT_FILE_NAME: minidlna
:DESCRIPTION: DLNA es un servidor multimedia
:EXPORT_DATE: 2018-12-27 21:00 2019-02-24 2019-03-24
:CATEGORY: servidor
:TAG:      servidor,raspberry,minidlna,multimedia
:IMAGE:    ./images/blog/dockeronrapi.png
:URL_AUDIO: https://anchor.fm/s/106db04/podcast/play/1672064/https%3A%2F%2Fd3ctxlq1ktw2nl.cloudfront.net%2Fstaging%2F2018-10-5%2FComo-Actualizar-tus-Dockers-9eca01f3ed771.m4a
:END:

DLNA es un servidor multimedia (video, audio y fotos) muy ligero, ya que simplemente hará una transferencia del archivo solicitado.

[[./images-blog/dlna.png]]

** Instalación

=sudo apt install minidlna=

** Archivo de configuración del servicio

=sudo nano /etc/minidlna.conf=

Añadiremos al inicio del archivo de configuración, la ruta donde están nuestros archivos multimedia. Ejem:

#+BEGIN_SRC 
media_dir=V,/media/Peliculas
media_dir=P,/media/Fotos
media_dir=A,/media/Musica
#+END_SRC

Si nuestro carpeta contiene, por ejemplo, vídeos y fotos, especificaremos de la siguiente manera:

=media_dir=PV,/media/Peliculas_y_ Fotos=

Si tenemos nuestros archivos multimedia en dos o más carpetas, podemos especificarlo así:
#+BEGIN_SRC 
media_dir=A,~/Música
media_dir=A,/media/Musica
#+END_SRC

** Descubrir el servidor en nuestra Red

Quitaremos la "#" delante de inotify y pondremos *yes*.
#+BEGIN_SRC  
# Automatic discovery of new files in the media_dir directory. 
inotify=yes
#+END_SRC

** Poner nombre a nuestro servidor

Aquí podremos poner nombre a nuestro servidor:
#+BEGIN_SRC
# Name that the DLNA server presents to clients.
friendly_name=Mi Servidor DLNA
#+END_SRC

** Añadir nuevo contenido Multimedia 
Para que todos los nuevos archivos multimedia que añadamos, sean añadidos de forma automática a nuestro servidor, deberemos tener habilitada esta opción en el archivo de configuración:
#+BEGIN_SRC 
# Automatic discovery of new files in the media_dir directory.
inotify=yes
#+END_SRC
**  Crear nueva base de datos
Para crear una nueva base de datos en nuestro servidor y eliminar la actual, por ejemplo, en el caso que cambiemos las carpetas donde esté nuestro contenido multimedia:

Borraremos la base de datos:  

=sudo rm -f /var/cache/minidlna/files.db=

Reiniciaremos el servidor

=sudo service minidlna restart=

Como has podido ver en este paso anterior, la base de datos así como las portadas de los archivos multimedia, están defecto en la carpeta */var/cache/minidlna*. Pero en el archivo de configuración, podemos cambiar la ruta. Para ello desmarcaremos la almohadilla y especificaremos la ruta deseada.

#+BEGIN_SRC 
# Path to the directory that should hold the database and album art cache.                                                                  
#db_dir=/var/cache/minidlna  
#+END_SRC

** Iniciar, Detener, Restaurar servicio

=exec /usr/sbin/service minidlna start=

o

=sudo systemctl start minidlna.service=

o

=sudo service minidlna start=

=sudo service minidlna stop=

=sudo service minidlna restart=



** Forzar el reescaneado

Cuando añadamos nuevo contenido a nuestra Biblioteca multimedia, es posible que no aparezca, esto se soluciona forzando la recarga de nuestra base de datos:

=sudo minidlnad -R ; sudo service minidlna restart=

o sino, podemos hacer:

=sudo service minidlna force-reload=

Si accedemos a nuestra IP:8200, veremos todo el contenido disponible a través de nuestro servidor DLNA.
** Puertos

En caso de tener cortafuegos, recordar abrir los puertos del servicio para poder acceder:
- TCP = 8200
- UDP = 1900

* Kde Connect en Emacs
:PROPERTIES:
:TITLE:    Kde Connect en Emacs
:EXPORT_FILE_NAME: kde-connecte-en-emacs
:DESCRIPTION: Por culpa del [[https://www.atareao.es/podcast/integrando-android-con-ubuntu/][Podcast de atareao.es]], he estado probando Kde Connect y la verdad es que ha pasado a ser una aplicación imprescindible en mi día a día. Tal como explica en su Podcast, existe la posibilidad de utilizarla con Emacs y como podéis imaginar, no me he podido resistir a probarla. Os explico como utilizarla
:EXPORT_DATE: 2018-12-31 22:00
:CATEGORY: emacs
:TAG:      emacs,sincronización,kdeconnect
:END:

Por culpa del [[https://www.atareao.es/podcast/integrando-android-con-ubuntu/][Podcast de atareao.es]], he estado probando Kde Connect y la verdad es que ha pasado a ser una aplicación imprescindible en mi día a día. Tal como explica en su Podcast, existe la posibilidad de utilizarla con Emacs y como podéis imaginar, no me he podido resistir a probarla. Os explico como utilizarla:

** Instalación

Teniendo los repositorios de Melpa:

    1) Instalación: *M-x package-install RET kdeconnect*
    2) Listamos los dispositivos de nuestra red local: *M-x kdeconnect-list-devices*
    3) Buscamos los búfer anteriores para copiar los id de nuestros dispositivos (C-x Izquierda)
    4) Introducimos el id de nuestro dispositivo: *M-x kdeconnect-select-active-device RET id*
    5) Hacemos un ping para comprobar que se ha conectado correctamente: *M-x kdeconnect-ping*

YA ESTA!!!

*Ahora si copiamos un texto en el portapapeles de nuestro Emacs, podremos pegarlo en el otro dispositivo gracias a Kde Connect.*

Vamos a enviar un texto desde Emacs al otro dispositivo *M-x kdeconnect-ping-msg RET Texto*

Os dejo el resto de funciones para que juguéis y el repositorio donde está toda la información:

** Resto de Funciones disponibles

| Función                         | 	Descripción                                                               |
|---------------------------------+-----------------------------------------------------------------------------|
| kdeconnect-get-active-device    | 	Mostrar el dispositivo activo                                             |
| kdeconnect-list-devices         | 	Muestra todos los dispositivos visibles, incluso los no disponibles.      |
| kdeconnect-ping                 | 	Enviar una notificación al dispositivo activo.                            |
| kdeconnect-ping-msg             | 	Envía una notificación con un mensaje personalizado al dispositivo activo |
| kdeconnect-refresh              | 	Escanee la red y actualice las conexiones disponibles                     |
| kdeconnect-ring                 | 	Hacer que suene el dispositivo activo (útil para encontrarlo)             |
| kdeconnect-select-active-device | 	Seleccione el dispositivo activo de kdeconnect-devices                    |
| kdeconnect-enviar-archivo       | 	Enviar el archivo seleccionado al dispositivo activo                      |
| kdeconnect-enviar-sms           | 	Enviar un SMS al destino especificado                                     |

[[https://github.com/carldotac/kdeconnect.el][Repositorio en GitHub]]

* Descargar todos los episodios de un Podcast con wget
:PROPERTIES:
:TITLE:    Descargar todos los episodios de un Podcast con wget
:EXPORT_FILE_NAME: descargar-todos-los-episodios-de-un-podcast-con-bash
:DESCRIPTION: Si estas en esta web probablemente conozcas mi Podcast y quizás te hayas planteado alguna vez si existe un método para descargar todos los Podcast disponibles sin necesidad de hacer uso de un programa sino desde la terminal y con wget.
:EXPORT_DATE: 2018-12-28 10:00
:CATEGORY: terminal
:TAG:      bash,podcast,unix,terminal
:IMAGE:    ./images/blog/dockeronrapi.png
:URL_AUDIO: https://anchor.fm/s/106db04/podcast/play/1672064/https%3A%2F%2Fd3ctxlq1ktw2nl.cloudfront.net%2Fstaging%2F2018-10-5%2FComo-Actualizar-tus-Dockers-9eca01f3ed771.m4a
:END:

Si estas en esta web, probablemente conozcas mi Podcast y quizás te hayas planteado alguna vez si existe un método para descargar todos los Podcast disponibles, sin necesidad de hacer uso de un programa, sino desde la terminal y con wget.

Tan simple como escribir esta única línea sustituyendo *"FEED"*, por el Feed del Podcast que desees descargar.
#+BEGIN_SRC 
wget -q -O- "FEED" | grep -o '<enclosure url="[^"]*' | grep -o '[^"]*$' | xargs wget -c
#+END_SRC

Como ejemplo, te dejo el Podcast de uGeek 😜
#+BEGIN_SRC  
wget -q -O- "http://feeds.feedburner.com/ugeek" | grep -o '<enclosure url="[^"]*' | grep -o '[^"]*$' | xargs wget -c
#+END_SRC
A disfrutar con la magia de la terminal...

* Visualiza tus Notas Markdown Versión Web con MkDocs
:PROPERTIES:
:TITLE:    Visualiza tus Notas Markdown Versión Web con MkDocs
:EXPORT_FILE_NAME: Visualiza tus Notas Markdown Version Web con MkDocs
:DESCRIPTION: Voy a explicaros como instalar MkDocs, levantar un servidor y poder ver todas vuestras nota en una interfaz web.
:EXPORT_DATE: 2019-01-03 12:05
:CATEGORY: servidor
:TAG:      servidor,raspberry,markdown,notas
:IMAGE:    ./images/blog/dockeronrapi.png
:URL_AUDIO: https://anchor.fm/s/106db04/podcast/play/1672064/https%3A%2F%2Fd3ctxlq1ktw2nl.cloudfront.net%2Fstaging%2F2018-10-5%2FComo-Actualizar-tus-Dockers-9eca01f3ed771.m4a
:END:

Voy a explicaros como instalar MkDocs, levantar un servidor y poder ver todas vuestras nota en una interfaz web.

** Instalación

Instalaremos en debian, ubuntu,… con:

=sudo apt install mkdocs=

También podemos hacerlo por Python así:

=sudo pip install mkdocs=

** Iniciando

Ahora vamos a crear un nuevo proyecto, una carpeta donde depositaremos todas nuestras notas para después verlas en la web.
#+BEGIN_SRC 
mkdocs new my-project
cd my-project
#+END_SRC

** Iniciamos el servidor

=mkdocs serve=

Para acceder remotamente, desde cualquier dispositivo dentro de nuestra red local, ejecutaremos dentro de la carpeta anteriormente creada:

=mkdocs serve -a 0.0.0.0:8000=

Ahora nos conectaremos desde cualquier dispositivo a: http://ip:8000

Si quieres publicarlo en tu servidor web de un modo permanente, con un comando podremos generar un sitio estático a partir de nuestro MkDocs.

Nos situamos en la raíz de la carpeta, donde arrancamos el servidor y ejecutamos:

=mkdocs build=

Esto creará una carpeta llamada site, que contendrá todos los archivos de nuestra web estática.

* El poder de la terminal y el scripting
:PROPERTIES:
:TITLE:    El poder de la terminal y el scripting
:EXPORT_FILE_NAME: El poder de la terminal y el scripting
:DESCRIPTION: Hace más de medio año que los chicos de Slimbook crearon lo que llaman un Centro de divulgación y aprendizaje de GNU/Linux y tecnologías abiertas, Linux Center
:EXPORT_DATE: 2019-01-03
:CATEGORY: unix
:TAG:      bash,terminal,scrits
:IMAGE:    ./images/blog/dockeronrapi.png
:URL_AUDIO: https://anchor.fm/s/106db04/podcast/play/1672064/https%3A%2F%2Fd3ctxlq1ktw2nl.cloudfront.net%2Fstaging%2F2018-10-5%2FComo-Actualizar-tus-Dockers-9eca01f3ed771.m4a
:END:

Hace más de medio año que los chicos de [[https://slimbook.es/][Slimbook]] crearon lo que llaman un Centro de divulgación y aprendizaje de GNU/Linux y tecnologías abiertas, [[https://linuxcenter.es/][Linux Center]].
El objetivo principal, es el de dar conocimiento tanto del Software Libre como de GNU/Linux. Allí se brinda la posibilidad, tanto de ofrecer charlas como asistir a ellas de forma totalmente gratuita. Afortunadamente, todos aquellos que vivimos lejos de Valencia, podemos ver estas a través de su [[https://www.youtube.com/channel/UCEGWt2UciVyz1MC7rYtBg6w][canal en YouTube]]. Os dejo esta charla muy interesante sobre la terminal que impartió  Raúl Rodrigo.

#+HTML: <iframe width="560" height="315" src="https://www.youtube.com/embed/AgvRdj2-Yog" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>  

* Eliminar líneas en Blanco con sed
:PROPERTIES:
:TITLE:    Eliminar líneas en Blanco con sed
:EXPORT_FILE_NAME: eliminar-lineas-en-blanco
:DESCRIPTION: Como podemos eliminar líneas en Blanco
:EXPORT_DATE: 2018-12-27 13:22
:IMAGE:    ./images/blog/dockeronrapi.png
:CATEGORY: unix
:TAG:      bash,unix,terminal,sed
:URL_AUDIO: https://anchor.fm/s/106db04/podcast/play/1672064/https%3A%2F%2Fd3ctxlq1ktw2nl.cloudfront.net%2Fstaging%2F2018-10-5%2FComo-Actualizar-tus-Dockers-9eca01f3ed771.m4a
:END:

Para eliminar líneas en Blanco de un archivo de texto, podriamos utilizar *sed*.

[[./images-blog/sed.png]]


=cat archivo | sed '/^ *$/d' > nuevo_archivo=

* Crear un Blog en GitLab. GitLab Pages
:PROPERTIES:
:TITLE:    Crear un Blog en GitLab. GitLab Pages
:EXPORT_FILE_NAME: Crear un Blog en GitLab. GitLab Pages
:DESCRIPTION: Crear un blog en GitLab no es una mala decisión, teniendo en cuenta que nos proporciona un hosting totalmente gratuito, a través de las GitLabPages y sin límite de espacio ni tráfico.
:EXPORT_DATE: 2019-01-04 14:36
:CATEGORY: git
:TAG:      gitlab, servidor, blog, html, git
:END:

** Intro

Crear un blog en GitLab no es una mala decisión, teniendo en cuenta que nos proporciona un hosting totalmente gratuito, a través de las [[https://pages.github.com/][GitLabPages]] y sin límite de espacio ni tráfico. El único limite, creo recordar, es que los archivo que subamos no pueden exceder de 15mb. Aún así, para mi es más que suficiente. 

Dando por hecho que ya tienes una cuenta creada, solo falta decidir si el repositorio que vas a crear, será como uno de tus proyectos o vas a crear un grupo. El punto positivo de crear el grupo, es que podrás elegir una url tipo miblog.gitlab.io.

También decir que el repositorio que crees, a diferencia de GitHub, podrás hacerlo tanto público como privado. Eso no exime el correcto funcionamiento de la Página en el servidor web. 

Imaginar tener vuestra Raspberry con git instalado y enviando información a nuestro servidor GitLab mediante cron. Esto puede ser muy muy interesante, una puerta de acceso al mundo exterior. jejeje

** Creamos el repositorio

Una vez creado el repositorio, tendremos que crear un archivo llamado  *.gitlab-ci.yml* y dentro de este, escribir el siguiente código:
#+BEGIN_SRC 
pages:
  script:
  - mkdir .public
  - cp -r * .public
  - mv .public public
  artifacts:
    paths:
    - public
  only:
  - master
#+END_SRC

** Crear el servidor

1) Vamos al apartado *CI/CC*
2) Vamos a *Configuración -> General -> Avanced -> Expand*
3) En Path, añadimos junto al proyecto, el dominio que queremos utilizar. Ejem: miblog.gitlab.io
4) Esperamos aproximadamente un minuto, veremos desde la página de GitLab una animación de una redonda que va cargando y...

Ya Está!!! Nuestro servidor esta funcionando!!!

* Elimina archivos duplicados con fduples
:PROPERTIES:
:TITLE:    Elimina archivos duplicados con fduples
:EXPORT_FILE_NAME: Elimina archivos duplicados con fduples
:DESCRIPTION: fduples es una herramienta que está disponible en los repositorios y nos permite eliminar ficheros duplicados
:EXPORT_DATE: 2019-01-05 11:39
:CATEGORY: terminal
:TAG:      bash,unix,terminal
:END:

fduples es una herramienta que está disponible en los repositorios y nos permite eliminar ficheros duplicados:

** Instalación

=sudo apt install fdupes=

** Ver cuantos archivos duplicados tenemos

Para *ver los archivos duplicados* en una carpeta, utilizaremos el siguiente comando:

=fdupes ~/ruta=

** Eliminar archivos duplicados

En caso de aparecer archivos, para eliminarlos, utilizaremos =-d=:

=fdupes -d ~/ruta=

Tranquilo, esto no eliminará los archivos, simplemente mostrará un asistente donde aparecerán los archivos repetidos y cual de ellos, mediante un número delante, queremos conservar:

#+BEGIN_SRC 
Set 1 of 147, preserve files [1 - 2, all]: 1

   [+] /home/angel/fotos/photo_0001.jpg
   [-] /home/angel/fotos/2019-01-05-15:15.jpg
#+END_SRC
Para entrar recursivamente a subcarpetas dentro de esta, utilizaremos como siempre =-r=

=fdupes -d ~/ruta=
* NextcloudPi. Nextcloud en Raspbian con Docker
:PROPERTIES:
:TITLE:    NextcloudPi. Nextcloud en Raspbian con Docker
:EXPORT_FILE_NAME: NextcloudPi. Nextcloud en Raspbian con Docker
:DESCRIPTION: Tal como os prometí en el podcast, entro más al detalle con la instalación del Docker oficial de Nextcloud para Raspberry. NextcloudPi
:EXPORT_DATE: 2019-01-06 14:33
:CATEGORY: servidor
:TAG:      docker, nextcloud
:END:

** Descargar Imagen y Crear Contenedor NextcloudPi

Tal como os prometí en el podcast, entro más al detalle con la instalación del Docker oficial de Nextcloud para Raspberry. NextcloudPi.

Si tenemos un servidor como apache2, vamos a detener el servicio para no utilizar el puerto 80, que éste utiliza por defecto.

Tendrás que modificar en este comando el usuario *pi* por tu usuario y la ip *192.168.1.100* por la ip local de tu raspberry.

#+BEGIN_SRC 
sudo docker run -d -p 4443:4443 -p 443:443 -p 80:80 -v /home/pi/docker/nextcloudplus/:/data --name nextcloudpi ownyourbits/nextcloudplus-armhf 192.168.1.100
#+END_SRC

** Iniciar Nextcloud

Una vez montado, nos conectaremos a nuestra ip:443. Nos aparecerá una web con el usuario ncp y dos contraseñas creadas de forma aleatoria.

Guardamos las 2 contraseñas y le damos a *Activar* en la parte inferior.

Una contraseña será para la web de administración de *NextcloudPi* por el puerto 4443 y la otra contraseña será para el servicio *Nextcloud* por el puerto 80 o 443.

** Crear Certificado

Si no tenemos una ip pública estática, recomiendo el utilizar un servicio como Duck DNS.

Ahora vamos a ip::4443 y vamos a crear el certificado en el apartado: Let’s Encrypt.

Abriremos los puertos 443 y 80 de nuestro Router, dirigiendo el tráfico a la ip local de nuestra Raspberry y clicaremos *Ejecutar*.

De forma automática, nos generará el certificado por 3 meses.

[[https://ownyourbits.com/nextcloudpi/][NextcloudPi]]

* Crear un Blog en GitHub. GitHub Pages
:PROPERTIES:
:TITLE:    Crear un Blog en GitHub. GitHub Pages
:EXPORT_FILE_NAME: Crear un Blog en GitHub. GitHub Pages
:DESCRIPTION: Vamos a utilizar GitHub para publicar un blog, una web estática, incluso podríamos ver archivos formato en markdown
:EXPORT_DATE: 2019-01-08 17:14
:CATEGORY: git
:TAG:      git, servidor, blog, html,
:END:

Vamos a utilizar GitHub para publicar un blog, una web estática, incluso podríamos ver archivos formato en markdown.

Ya os expliqué hace días como hacerlo en GitLab, deciros que en GitHub hay un poco mas de limitaciones, pero al final, podemos hacerlo.

Algunas de las limitaciones de GitHub Pages son que las páginas no pueden ocupar mas de 1Gb, el ancho de banda no puede superar los 100Gb al mes y solo permite 10 actualizaciones por hora de la web.

Me he vuelto un poco loco con las carpetas donde estaban las imágenes, ya que las había nombrado como "__icon", "__css"... y a GitHub Pages no le gustaba que se nombraran de este modo, ya que no las mostraba. Importante, si quieres que las carpetas sean accesibles desde el servidor web, que no empiecen con símbolos raros.

** Creando la Web estática con GitHub Pages

1) Creamos el repositorio en GitHub
2) Bajamos este, a nuestro dispositivo haciendo un =git clone repositorio=
3) Ya tenemos nuestra carpeta de GitHub en local. Añadimos los archivos .html que queremos subir a nuestro GitHub Pages
4) Subimos todos los archivos a GitHub con los comandos: =git add . ; git commit -m "primer commit" ; git push=
5) Ahora vamos a habilitar el servidor web. Vamos a *Settings*
6) En el apartado *GitHub Pages*, en *Source*, cambiamos el estado de *None* a *Master Branch*. Despues pulsaremos el boton *Save*
7) Ya está guardado y si volvemos a este apartado de *GitHub Pages*, aparecerá la nueva url creada para nuestro nuevo servidor web, tipo:  https://ugeek.github.io/nombre_del_repositorio/ 

* Ignorar archivos que no queremos que suban a Git
:PROPERTIES:
:TITLE:    Ignorar archivos que no queremos que suban a Git
:EXPORT_FILE_NAME: Ignorar archivos que no queremos que suban a Git
:DESCRIPTION: Es muy probable que no queramos que suban absolutamente todos nuestros archivos a nuestro repositorio en GitHub, GitLab, etc... Esto tiene un a fácil solución:
:EXPORT_DATE: 2019-01-12 21:00
:CATEGORY: git
:TAG:      git,
:END:
 Es muy probable que no queramos que suban absolutamente todos nuestros archivos a nuestro repositorio en GitHub, GitLab, etc... Esto tiene una fácil solución:
** Creando el archivo *.gitignore* para ignorar archivos 
Para determinar los archivos que queremos que no suban al repositorio, tenemos que crear una archivo de texto plano oculto llamado *.gitignore en la raíz de la carpeta en la que queramos ignorar ese tipo de archivo.*

Hay que tener en cuenta, que si lo ponemos en la raíz inicial del proyecto, esto excluirá a esa carpeta y resto de subcarpetas de este repositorio.

La sintaxis es prácticamente igual que si hiciéramos un scritp en bash. "#" podemos utilizarlo para los comentarios.

- Si no queremos que *no* suban los archivos extensión .log, utilizariamos:
 
 =*.log=
  
* GPG. Cifrado de archivos simétrico
:PROPERTIES:
:TITLE:    GPG. Cifrado de archivos simétrico
:EXPORT_FILE_NAME: GPG Cifrado de archivos simetrico
:DESCRIPTION: En este post vamos a ver como cifrar simetricamente, con una contraseña, archivos mediante gpg
:EXPORT_DATE: 2019-01-17 21:20
:CATEGORY: seguridad
:TAG:      gpg, nube, servidor, raspberry
:END:

En este post vamos a ver como cifrar simetricamente, con una contraseña, archivos mediante gpg.
 
** Cifrado

=gpg -c archivo.txt=
 
Te pedirá contraseña para cifrar el archivo.

Si eres como yo y te gusta incluirlo en un script para automatizar y no tener poner contraseña:
#+begin_src
gpg --yes --batch --passphrase="pon aquí tu contraseña" -c archivo.txt
#+end_src
** Descifrado

=gpg archivo.txt.gpg=


Para automatizar como en el caso anterior...
#+begin_src 
gpg --yes --batch --passphrase="pon aquí tu contraseña" archivo.txt.gpg
#+end_src
** Conclusión
Hablaré en más posts de como cifrar con diferentes métodos. Aunque el cifrado simétrico no es altamente seguro, si lo incluimos en un script, podriamos darle varias pasaditas de cifrado automatizando el proceso, dandole un poco mas de seguridad.




* Servidor de Mensajería Matrix para Raspberry. Cliente Riot.
:PROPERTIES:
:TITLE:    Servidor de Mensajería Matrix para Raspberry. Cliente Riot
:EXPORT_FILE_NAME: Servidor de Mensajeria Matrix para Raspberry Cliente Riot
:DESCRIPTION: Hace algo mas de un mes, estoy utilizando Matrix Synapse, juntamente con el cliente Riot, a través de mi servidor-raspberry de forma totalmente privada y teniendo la totalidad de la gestión del servicio como los usuarios registrados. De momento, no he federado mi servidor, de manera que únicamente podremos comunicarnos los usuarios registrados en este servidor.
:EXPORT_DATE: 2019-01-20 19:26
:CATEGORY: mensajeria
:TAG:      servidor, raspberry
:END:

Hace algo mas de un mes, estoy utilizando Matrix Synapse, juntamente con el cliente Riot, a través de mi servidor-raspberry de forma totalmente privada y teniendo la totalidad de la gestión del servicio como los usuarios registrados. De momento, no he federado mi servidor, de manera que únicamente podremos comunicarnos los usuarios registrados en este servidor.

Voy a explicaros paso a paso, como crear vuestro servidor en raspbian y si abrís los puertos del servicio, podréis comunicaros dentro y fuera de vuestra red local, con una de las aplicaciones de comunicación de Software Libre, mas seguras que existen en la actualidad, ya que posee de doble cifrado de datos.

Características:

  - Mensajería
  - Ilimitadas Salas donde poder compartir mensajes, imágenes, archivos,…
  - Llamadas
  - Video Llamadas
  - Doble Cifrados
  - Varios Clientes y totalmente multiplataforma

** INSTALACIÓN DEL SERVIDOR EN RASPBIAN
#+begin_src 
sudo apt-get install build-essential python2.7-dev libffi-dev \
                     python-pip python-setuptools sqlite3 \
                     libssl-dev python-virtualenv libjpeg-dev
sudo pip install --upgrade pip
sudo pip install --upgrade ndg-httpsclient
sudo pip install --upgrade virtualenv
#+end_src

Este segunda comando ten paciencia, se crearan los certificados, etc … y *tardará mucho tiempo, probablemente una hora*, recomiendo detener servicios

#+begin_src 
virtualenv -p python2.7 ~/.synapse
source ~/.synapse/bin/activate
pip install --upgrade pip
pip install --upgrade setuptools
pip install https://github.com/matrix-org/synapse/tarball/master
#+end_src

Instala también el modulo para synapse.app.

=pip install (--upgrade) synapseclient=

** CONFIGURAR SYNAPSE

    Recuerda sustituir el nombre del servidor *my.domain.name*
    En –report-stats= tienes que seleccionar *yes o no*.

=cd ~/.synapse=

#+begin_src 
python2.7 -B -m synapse.app.homeserver \
    --server-name=my.domain.name \
    --config-path=homeserver.yaml \
    --generate-config \
    --report-stats=[yes|no]
#+end_src


** INICIAR SERVIDOR

1) Nos situamos en la carpeta de *synapse*

=cd ~/.synapse=

2) Iniciar el servidor

=source ./bin/activate ; synctl start=

La Terminal nos devolverá que por el puerto 8008, encontraremos una inferfaz de gestión. Esta es antigua, *no te recomiendo que la uses*, te recomiendo crear ususarios mediante el comando que veremos mas adelante.
*Detener el servicio, si lo deseamos:*

=source ./bin/activate ; synctl stop=

CREAR USUARIOS

Iniciamos el servidor y situándonos dentro del directorio *.synapse*

=cd ~/.synapse=

Ejecutaremos el siguiente comando:

=register_new_matrix_user -c homeserver.yaml https://localhost:8448=

Ahora nos preguntará por el usuario, contraseña y si este usuario es administrador o no.
** UTILIZAR EL CLIENTE RIOT

[[./images-blog/riot.png]]


1) Pondermos en nombre de usuario y contraseña
2) Habilitamos opciones de servidor propietarias
3) En servidor, ponemos https://ip:8448
ENCONTRARSE LOS USUARIOS

1) Creamos una sala
2) En configuración de la sala, en *acceso a la Sala* y seleccionamos:
 
“Los que saben el enlace de la sala, incluso huespedes”

3 )Ahora en *Avanzado*, compartimos al otro usuario *La identificación interna de esta Sala*
  
* Crear el Feed para el podcast en tu Blog con Jekyll
:PROPERTIES:
:TITLE:    Crear el Feed para el podcast en tu Blog con Jekyll
:EXPORT_FILE_NAME: Crear el Feed para el podcast en tu Blog con Jekyll
:DESCRIPTION: Voy a explicar en este post, como generar el Feed del podcast de forma automática.
:EXPORT_DATE: 2019-01-21 16:16
:CATEGORY: jekyll
:TAG:      servidor, jekyll,rss
:END:

Voy a explicar en este post, como generar el Feed del podcast de forma automática.

** Creamos un archivo podcast.xml en la raiz, con el siguiente contenido:
#+begin_src 
---
layout: null
---
<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
xmlns:content="http://purl.org/rss/1.0/modules/content/"
xmlns:wfw="http://wellformedweb.org/CommentAPI/"
xmlns:dc="http://purl.org/dc/elements/1.1/"
xmlns:atom="http://www.w3.org/2005/Atom"
xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
xmlns:itunes="http://www.itunes.com/dtds/podcast-1.0.dtd"
xmlns:rawvoice="http://www.rawvoice.com/rawvoiceRssModule/"
>
 
<channel>
<title>{{ site.podcast_title }}</title>
<atom:link href="{{ site.url }}/feed/podcast" rel="self" type="application/rss+xml" />
<link>{{ site.url }}</link>
<description>{{ site.podcast_description }}</description>
<lastBuildDate>{{ site.time | date: "%a, %d %b %Y %H:%M:%S %z" }}</lastBuildDate>
<language>es-es</language>
<sy:updatePeriod>hourly</sy:updatePeriod>
<sy:updateFrequency>1</sy:updateFrequency>
<generator>http://jekyllrb.com</generator>
<itunes:summary>{{ site.podcast_summary }}</itunes:summary>
<itunes:author>{{ site.podcast_author }}</itunes:author>
<itunes:explicit>{{ site.podcast_explicit }}</itunes:explicit>
<itunes:image href="{{ site.url }}{{ site.podcast_album_art }}" />
<itunes:owner>
<itunes:name>{{ site.podcast_owner }}</itunes:name>
<itunes:email>{{ site.podcast_email }}</itunes:email>
</itunes:owner>
<managingEditor>{{ site.podcast_email }} ({{ site.podcast_owner }})</managingEditor>
<itunes:subtitle>{{ site.podcast_subtitle }}</itunes:subtitle>
<image>
<title>{{ site.podcast_title }}</title>
<url>{{ site.url }}{{ site.podcast_album_art }}</url>
<link>{{ site.url }}</link>
</image>
<itunes:category text="{{ site.podcast_category }}">
<itunes:category text="{{ site.podcast_subcategory_one }}" />
<itunes:category text="{{ site.podcast_subcategory_two }}" />
</itunes:category>
{% for ep in site.categories.podcast %}
  <item>
    <title>{{ ep.title }}</title>
    <link>{{ site.url }}{{ ep.url }}</link>
    <comments>{{ site.url }}{{ ep.url }}#comments</comments>
    <pubDate>{{ ep.date | date: "%a, %d %b %Y %T %z" }}</pubDate>
    <dc:creator><![CDATA[{{ site.author | cdata_escape }}]]></dc:creator>
{% for category in ep.categories %}
    <category><![CDATA[{{ category | cdata_escape }}]]></category>
{% endfor %}
{% for category in ep.tags %}
    <category><![CDATA[{{ category | cdata_escape }}]]></category>
{% endfor %}
    <guid isPermaLink="{% if ep.podcast_guid %}false{% else %}true{% endif %}">{{ site.url }}{% if ep.podcast_guid %}/{{ ep.podcast_guid }}{% else %}{{ ep.url }}{% endif %}</guid>
    <description>
        <![CDATA[{{ ep.excerpt | strip_html | truncatewords: 50 | expand_urls: site.url | cdata_escape }}]]>
    </description>
    <content:encoded>
        <![CDATA[{{ ep.content | expand_urls: site.url | cdata_escape }}]]>
    </content:encoded>

    <enclosure url="{{ ep.podcast_link }}" length="{{ ep.podcast_length }}" type="audio/mpeg" />
    <itunes:subtitle><![CDATA[{{ ep.excerpt | strip_html | truncatewords: 50 | expand_urls: site.url | cdata_escape }}]]></itunes:subtitle>
    <itunes:summary><![CDATA[{{ ep.content | expand_urls: site.url | cdata_escape }}]]></itunes:summary>
    <itunes:author>{{ site.podcast_author }}</itunes:author>
    <itunes:image href="{{ site.url }}{{ site.podcast_album_art }}" />
    <itunes:explicit>{{ site.podcast_explicit }}</itunes:explicit>
    <itunes:duration>{{ ep.podcast_duration }}</itunes:duration>
  </item>
{% endfor %}
</channel>
</rss>
#+end_src

** Añadimos en el archivo _config.yml, el siguiente contenido:

#+begin_src 
# Podcast Feed Settings
podcast_url: https://ugeek.github.io
podcast_album_art: https://ugeek.github.io/img/ugeek.png
podcast_title: uGeek
podcast_owner: Angel
podcast_email: ugeekpodcast@gmail.com
podcast_category: Technology
podcast_subcategory_one: Linux
podcast_subcategory_two: Gadgets
podcast_explicit: "no"
podcast_author: Angel
podcast_description: Podcast de Tecnología en el que hablo de GNU/Linux, Raspberry Pi, servidores y tecnología en general.
podcast_summary: Podcast de Tecnología en el que hablo de GNU/Linux, Raspberry Pi, servidores y tecnología en general.
podcast_subtitle: Podcast de Tecnología en el que hablo de GNU/Linux, Raspberry Pi, servidores y tecnología en general.
#+end_src
** Por último, añadiremos en cada post, que es un podcast, el link del mp3, imagen, tags, etc…
#+begin_src 
---
layout: post
title: "046. Sincronización de carpetas entre dispositivos. Syncthing, Resilio y Dukto"
date: 2017-04-21
categories: podcast
image: img/ugeek.png
podcast_link: https://ia601509.us.archive.org/6/items/046SyncthingResilioYDukto/%23046%20Syncthing%2c%20Resilio%20y%20Dukto%20.mp3
tags: [syncthing, resilio, dukto, sincronización carpetas, podcast]
comments: true
---
#+end_src

* Utilizando Git con la Terminal. GitHub 
:PROPERTIES:
:TITLE:    Utilizando Git con la Terminal. GitHub
:EXPORT_FILE_NAME: Utilizando Git con la Terminal GitHub
:DESCRIPTION: Como siempre os he comentado, utilizar la terminal al principio impresiona, pero hay que reconocer que no hay herramienta más productiva y potente que esta. Vamos a aprovechar que GitHub ha añadido repositorios privados, para utilizar más Git y vía terminal
:EXPORT_DATE: 2019-01-21 15:16 
:CATEGORY: git
:TAG:      terminal,github
:END:

Como siempre os he comentado, utilizar la terminal al principio impresiona, pero hay que reconocer que no hay herramienta más productiva y
potente que esta. Vamos a aprovechar que GitHub ha añadido repositorios privados, para utilizar más Git y vía terminal.

** Instalando Git
=sudo apt install git=

** Comprobar si tenemos clave pública ssh
Vamos a comprobar si tenemos clave pública ssh generada. Para ello, entramos en *~/.ssh* y miraremos si existe el archivo **.pub*. 
** Generando tu clave pública ssh
Si no existe, vamos a generarlo.

Ejecutaremos el comando:

=ssh-keygen=

Saldrán una serie de preguntas. puedes ir pulsando intro para dejar los valores por defecto. eso no influye en nada.

Cuando termine, aparecerán un par de ficheros dentro de *~/.ssh/* se llamarán *id_rsa* y *id_rsa.pub* o adquirirán el nombre que has elegido si has puesto alguno en el paso anterior.

Ahora abre el fichero acabado en *.pub* con algún editor de textos y copia el contenido. Yo recomiendo utilizar la terminal:

=cat id_rsa.pub=

** Añadiendo la  clave en GitHub
Haz click en tu foto de perfil de arriba a la derecha, después ve a *settings > SSH and GPG keys > New SSH key*. Pega la clave  y pulsa finalizar.

A partir de ahora ya tienes permisos para subir cambios a tus repositorios en local.

Comprobaremos la conexión con GitHub

=ssh -T git@github.com=

** Iniciando cuenta con GitHub

Solo la primera vez, especificamos nuestro correo y nombre de usuario:

=git config --global user.email "tucorreo@gmail.com"=

=git config --global user.name "Tu Nombre"=

Para ver el archivo de configuración:

=cat ~/.gitconfig=

** Clonar Repositorio en local
Ves al repositorio de GitHub y haz click en *Clone or download* en la zona de la derecha, te saldrá *Clone with HTTPS o Clone with SSH GitHub*

Haz click sobre *Use SSH* y después pulsa sobre el botón de copiar que hay debajo.
 
Ahora vamos a la terminal y pegamos la url con *git clone* para clonar el repositorio:

=git clone git@github.com:ugeek/ugeek.github.io.git=

Se descargará todo el repositorio descomprimido en nuestra máquina. Ya podrás trabajar en local!


** Comandos Básicos
Resumen de pasos básicos para enviar archivos a una rama master de GitHub, serian estos:

- Ver estado desde el último cambio  =git status=
- Añadimos a git todos los cambios de archivos que hemos creado o cambiado en local =git add .=
- Igual que el anterior, pero solo una archivo =git add archivo= 
- Commit es una breve explicación del cambio o nuevo archivo que enviamos =git commit -m "nuevo post"=
- Empujamos el archivo, ahora si, a GitHub con =git push origin master=. Si se ponemos =git push --set-upstream origin master=, las siguientes veces funcionará poniendo sólo =git push=

    
Si tenemos instalado GitHub en dos dispositivos, antes de editar, deberíamos verificar o descargar el contenido remoto de GitHub a local.
- Para ello escribiremos en la terminal =git pull origin master=, después, igual que el caso anterior, podremos utilizar =git pull= a secas.

** Resumen
Esta guía sirve tanto para GitHub, GitLab y resto de servidores con Git. Como veis, parece muy complicado por ver muchos comandos, pero en el día a día, todo se resume en *subir* y *bajar*, los archivos de una carpeta al repositorio remoto.

Todo se resume en:

Subir

=git add . ; git commit -m "comentario" ; git push=

Bajar

=git pull=
* Antergos. Comandos para terminal y derivadas de Arch Linux
:PROPERTIES:
:TITLE:    Antergos. Comandos para terminal y derivadas de Arch Linux
:EXPORT_FILE_NAME: Antergos Comandos para terminal y derivadas de Arch Linux
:DESCRIPTION: Los que venimos de Ubuntu, tenemos problemas al pasar a una dervada de Arch, porque no conocemos bien las instrucciones para actualizar el Sistema Operativo, instalar y demás
:EXPORT_DATE: 2019-01-21 18:30 
:CATEGORY: arch'
:TAG:      antergos,comandos,terminal
:END:

Los que venimos de Ubuntu, tenemos problemas al pasar a una dervada de Arch, porque no conocemos bien las instrucciones para actualizar el
Sistema Operativo, instalar y demás…

Aquí iré añadiendo periodicamente comandos para ir conociendolos.

** pacman
Pacman es el sistema de paquetes de Arch oficial, supervisado por ellos.
*** Actualizar el Sistema Operativo y repositorios
=sudo pacman -Syyuu=   
*** Buscar en los repositorios (usaremos de ejem: gimp)
=sudo pacman -Ss gimp=
*** Instalar aplicaciones
=sudo pacman -S gimp=
   
** yaourt
Las aplicaciones que no esten en los repositorios oficiales de Arch, estan en AUR. AUR (Arch User Repository) es el lugar donde la
comunidad de Arch Linux puede subir los PKGBUILD de las aplicaciones, bibliotecas, etc.,

Para instalar desde Aur utilizaremos yaourt.

*** Actualizar los repositorios
=yaourt -Syu=
   
*** Buscar en yaourt (usaremos de ejem: utext)
=yaourt -Ss utext=
   
*** Instalar aplicaciones que no encontremos en Pacman (como utext)
=yaourt -S utext=
   

** Guía de comandos básicos de Pacman
*** Instalar paquetes
- =pacman -S “paquete”=  Instala un paquete.
- =pacman -Sy “paquete”= Sincroniza repositorios e instala el paquete.
   
*** Actualizar paquetes
- =pacman -Sy=  Sincroniza repositorios.
- =pacman -Syy=  Fuerza la sincronización de repositorios incluso para paquetes que parecen actualizados.
- =pacman -Syu=  Sincroniza repositorios y actualiza paquetes.
- =pacman -Syyu=  Fuerza sincronización y actualiza paquetes.
- =pacman -Su=  Actualiza paquetes sin sincronizar repositorios.
   
*** Buscar paquetes
- =pacman -Ss “paquete”=  Busca un paquete.
- =pacman -Si “paquete”=  Muestra información detallada de un paquete.
- =pacman -Sg “grupo”=  Lista los paquetes que pertenecen a un grupo.
- =pacman -Qs “paquete”=  Busca un paquete YA instalado.
- =pacman -Qi “paquete”=  Muestra información detallada de un paquete YA instalado.
- =pacman -Qdt=  Muestra paquetes huerfanos.
   
*** Eliminar paquetes
- =pacman -R “paquete”=  Borra paquete sin sus dependencias.
- =pacman -Rs “paquete”=  Borra paquete y sus dependencias no utilizadas.


Fuente: sobrebits.com
  
** Aplicaciones Imprescindibles
Navegador Chrome

=yaourt -S google-chrome=

Editor de video

=sudo pacman -S openshot=

Notas de Nextcloud

=yaourt -S qownnotes=

Descarga videos de youtube

=sudo pacman -S clipgrab=

Hacer capturas de pantalla

=yaourt -S shutter=

Convertir audios de m4a a MP3

=sudo pacman -S soundconverter=

Editor de Fotografía

=sudo pacman -S gimp=

Instalar Inkscape

=sudo pacman -S inkscape=

Transmission

=sudo pacman -S transmission-gtk=

Skype

=sudo pacman -S skype=

* Paquetes Snap
:PROPERTIES:
:TITLE:    Paquetes Snap
:EXPORT_FILE_NAME: paquetes Snap
:DESCRIPTION: Snap es muy fácil de utilizar desde la terminal. Aquí dejo los comando más utilizados, para consultarlos cada vez que quieras y no olvidarlos. También una breve explicación de donde están los snaps en tu disco y la tienda de aplicaciones. 
:EXPORT_DATE: 2019-01-24 21:30 
:CATEGORY: snap
:TAG:      paquetes,
:END:
Snap es muy fácil de utilizar desde la terminal. Aquí dejo los comando más utilizados, para consultarlos cada vez que quieras y no olvidarlos. También una breve explicación de donde están los snaps en tu disco y la tienda de aplicaciones. 

** Tienda de aplicaciones
El amplio catalogo de snaps, los encontraras en una web gestionada por Canonical.
- https://snapcraft.io/store
** Instalación de snap, si no está en tu distro derivada de debian
=sudo apt install snapd=

Para otras distribuciones, visita https://snapcraft.io/
** Ubiación de los paquetes snap en nuestro sistema
Una vez instalado los paquetes, estos van a la ubicación */snap/bin/nombre_de_paquete*. Podemos conocer la ubicación con:

=which paquete=

También creará una carpeta llamada snap en el $HOME de nuestro usuario */home/usuario/snap/*, donde depositará snap los archivos de configuración de los paquetes.
** Tabla de comandos básicos snap

| Comando                                 | Utilidad                          |
|-----------------------------------------+-----------------------------------|
| =sudo snap refresh=                       | Actualizar todos los paquetes     |
| =sudo snap refresh paquete=               | Actualizar un determinado paquete |
| =snap list=                               | Listar los paquetes instalados    |
| =snap search paquete= o =snap find paquete= | Buscar Paquetes                   |
| =sudo snap install paquete=               | Instalar paquete                  |
| =sudo snap remove paquete=                | Desinstalar paquete               |
| =snap info paquete=                       | Información del paquete           |
| =snap disable paquete=                    | Deshabilitar un servicio          |
| =snap enable paquete=                     | Habilitar                         |
| =snap version=                            | Conocer la versión de snap        |
| =snap help=                               | Ayuda                             |


- Desde mi raspberry, no he podido actualizar con *snap refresh* y he tenido que utilizar *snap refresh syncthing,* en el caso de la versión 1.0 de Syncthing.
- Con *snap info paquete* nos aparece toda la información de este paquete,así como las actualizaciones que ha ido teniendo este.
- Utilizar la instrucción *disable*, deshabilitará por completo el paquete, no solo lo detendrá, sino que lo dejará inaccesible para el sistema. Como si no estuviera instalado.
* Castero. Podcatcher  ligero para Terminal
:PROPERTIES:
:TITLE:    Castero. Podcatcher  ligero para Terminal
:EXPORT_FILE_NAME: Castero Podcatcher ligero para Terminal
:DESCRIPTION: Hay muchas aplicaciones para escuchar podcast, pero ninguna tan ligera como esta. Desarrollada en python, [[https://github.com/xgi/castero][Castero]] nos permite suscribirnos a nuestro podcast favoritos y tanto descargarlos como escucharlos desde la terminal.
:EXPORT_DATE: 2019-01-26 14:00 
:CATEGORY: terminal
:TAG:      podcast,
:END:
Hay muchas aplicaciones para escuchar podcast, pero ninguna tan ligera como esta. Desarrollada en python, [[https://github.com/xgi/castero][Castero]] nos permite suscribirnos a nuestro podcast favoritos y tanto descargarlos como escucharlos desde la terminal.

[[./images-blog/castero.png]]

** Instalación

Si no tenemos los módulos de python pip:
=sudo apt install python3-pip=

Instalación de castero:

=sudo pip3 install castero=

Para poder escuchar los podcast, requiere de aplicaciones externas como vlc versión 2.2.3 o superior o mpv con libmpv

** Iniciando Castero
Tan simple como escribir en tu terminal 

=caster=

Se abrirá una pantalla dividida en 3 partes:
- Feed: Los podcast que estamos suscritos a través de su Feed
- Episodies: Los episodios disponibles para ser escuchados
- Metadata: La información del episodio seleccionado

** Uso
La verdad es que es muy sencillo de utilizar. No iremos desplazando por las columnas de la pantalla con los cursores de izquierda, derecha, arriba, abajo.

Para salir, como la mayoría de las app's de ternimal *q*.

Para añadir el Feed deseado *a*...
#+BEGIN_SRC 
Comandos
    h - pantalla de ayuda
    q - salir del cliente
    a - añadir un feed
    d - eliminar el feed seleccionado
    r - recargar / actualizar feeds
    s - guardar el episodio para la reproducción sin conexión
    flechas - navegar por los menús
    página arriba / abajo - menús de desplazamiento
    entrar - reproducir el feed / episodio seleccionado
    espacio - agregar el feed / episodio seleccionado a la cola
    c - borrar la cola
    n - ir al siguiente episodio en la cola
    i - Invertir el orden del menú
    p o k - pausa / reproducir el episodio actual
    f o l - buscar hacia adelante
    b o j - buscar hacia atrás
#+END_SRC


** Archivos de configuración
El archivo de configuración se encuentra en {HOME}/.config/castero/ después de que el cliente se haya ejecutado al menos una vez.
La información de los Podcast está en {HOME}/.local/share/castero/feeds , pero este archivo no se puede editar de forma manual.



- [[https://github.com/xgi/castero][Repositorio de Castero]] 
* Lee Super rápido en Emacs con Spray
:PROPERTIES:
:TITLE:    Lee Super rápido en Emacs con Spray
:EXPORT_FILE_NAME: Lee Super rapido en Emacs con Spray
:DESCRIPTION: No se si recordáis la aplicación Spritz, aquella aplicación que apareció a principios del año 2014 y que sus desarrolladores prometían que podríamos doblar o triplicar la velocidad de lectura. Si eres de aquellos que quieren leer más rápido o te cuesta concentrarte en la lectura de tus orgmode, voy a explicarte como instalarlo en el propio emacs de un modo sencillo.
:EXPORT_DATE: 2019-01-27 19:15 
:CATEGORY: emacs
:TAG:      melpa,
:END:
[[./images-blog/spray.gif]]

No se si recordáis la aplicación Spritz, aquella aplicación que apareció a principios del año 2014 y que sus desarrolladores prometían que podríamos doblar o triplicar la velocidad de lectura. Si eres de aquellos que quieren leer más rápido o te cuesta concentrarte en la lectura de tus orgmode, voy a explicarte como instalarlo en el propio emacs de un modo sencillo.
** Instalación
Instalaremos desde los repositorios de Melpa:

=M-x package-install RET spray=

**  Atajo de Teclado
La verdad es que si utilizamos un atajo instantáneo, tal como recomienda su desarrollador, aunque a priori pueda parecer una tontería, es un paquete que puede ser muy interesante tener instalado. El desarrollador recomienda utilizar la tecla *F6* para hacer uso de *spray*, aunque como sabes, puedes utilizar cualquier otro atajo si este ya lo tienes ocupado.

Para añadir este atajo, tenemos que añadir a nuestro archivo de configuración de emacs, ya sea el archivo *.emacs* o *init.el*, la siguiente línea:

=(global-set-key (kbd "<f6>") 'spray-mode)= 

** Modo de uso
La verdad es que es muy fácil de utilizar. Simplemente tenemos que situarnos el la parte del texto que deseamos leer y pulsar la tecla *F6*. Para salir de *spray*, pulsaremos nuevamente la tecla *F6*.

Algunos atajos mas:

| spray-start/stop (SPC)          | pausar o reanudar la fumigación              |
| spray-backward-word (h, <left>) | hacer una pausa y volver a la última palabra |
| spray-forward-word (l, <right>) | inversa de spray-backward-word               |
| spray-faster (F)                | aumenta la velocidad                         |
| spray-slower (s)                | disminuye la velocidad                       |
| spray-quit (q, <return>)        | dejar spray-mode                             |

Hay muchas mas opciones como cambiar la posición de spray en la pantalla, así como cambiar los colores. Si quieres entrar mas en profundidad, te recomiendo visitar el [[https://gitlab.com/iankelling/spray][repositorio del desarrollador.]]

- [[https://gitlab.com/iankelling/spray][Repositorio]]
* Crear ramas con Git
:PROPERTIES:
:TITLE:    Crear ramas con Git
:EXPORT_FILE_NAME: Crear ramas con Git
:DESCRIPTION: Todos los repositorios de git, tienen la rama master (este sería el repositorio en producción) Cuando queremos hacer una modificación de un archivo en un repositorio que está en producción, crearemos una rama alternativa con la que podremos trabajar y así no alterar el funcionamiento del repositorio master
:EXPORT_DATE: 2019-01-28 21:15 
:CATEGORY: git
:TAG:      git
:END:
Todos los repositorios de *git*, tienen la rama *master* (este sería el repositorio en producción) Cuando queremos hacer una modificación de un archivo en un repositorio que está en producción, crearemos una rama alternativa con la que podremos trabajar y así no alterar el funcionamiento del repositorio *master*. 

[[./images-blog/git.png]]

** Crear rama
Para crear una rama, utilizaremos el comando *git branch*. Vamos a crear una rama que llamaremos *test*

=git branch test=

** Cambiar de rama
Ahora tenemos una nueva rama, la rama *test*. Para acceder a ella, utilizaremos el comando *git checkout*

=git chekcout test=

Si hemos introducido este comando, ya no estaremos en la rama *master* , sino que en la rama test, de manera que podremos hacer todos los cambios que deseemos sin miedo a romper nada.

Antes de volver nuevamente a la rama *master*, tenemos que hacer un *git push* y poner al día la rama *test*.

Para volver a la rama *master*:

=git checkout master=

Ya estamos de nuevo en la rama *master*

** Borrar una rama
Si ya hemos acabado con la rama *test* y queremos eliminarla en el repositorio local, utilizaremos el comando *git branch -d*

=git branch -d test=

Para forzar el borrado en caso de algún error:

=git branch -D test=


Para eliminar el repositorio remosto *git push origin :*

=git push origin :test=

 
* Navegar por el Historial de comandos en Bash
:PROPERTIES:
:TITLE:    Navegar por el Historial de comandos en Bash
:EXPORT_FILE_NAME: Navegar por el Historial de comandos en Bash
:DESCRIPTION: Hace unas semanas, en el blog de Linuxito, vi este truquillo para navegar por el historial de comandos de nuestra terminal, utilizando las flechas de arriba y abajo. La verdad es que me he vuelto dependiente de este truco y quería compartirlo con vosotros. Igualmente, os recomiendo visitar el blog de Linuxito
:EXPORT_DATE: 2019-01-28 22:15 
:CATEGORY: bash
:TAG:      terminal
:END:

Hace unas semanas, en el blog de [[https://www.linuxito.com/][Linuxito]], vi este truquillo para navegar por el historial de comandos de nuestra terminal, utilizando las flechas de arriba y abajo. La verdad es que me he vuelto dependiente de este truco y quería compartirlo con vosotros. Igualmente, os recomiendo visitar el blog de [[https://www.linuxito.com/][Linuxito]], que siempre crea artículos muy interesantes.

** Creamos archivo .inputrc
En la raíz del directorio $HOME, crearemos el archivo oculto *.inputrc*. Utilizaremos por ejemplo *nano*, para crear el archivo.

=nano .inputrc=

Una vez abierto, copiaremos en el siguiente contenido:
#+BEGIN_SRC 
## Flecha Arriba
"\e[A":history-search-backward
## Flecha Abajo
"\e[B":history-search-forward
#+END_SRC
Espero que disfrutéis de este truquillo igual que yo.

- [[https://www.linuxito.com/2-uncategorised/1160-configurar-bash-para-que-las-flechas-de-teclado-se-comporten-como-en-csh][Fuente]]

* Que aparezca en el Prompt en que rama estamos   
:PROPERTIES:
:TITLE:    Que aparezca en el Prompt en que rama estamos
:EXPORT_FILE_NAME: Que aparezca en el Prompt en que rama estamos
:DESCRIPTION: Una vez te familiarizas con git, comienzas a crear ramas y llega un momento en el que vas un poco perdido, sin saber bien donde estás.Es cierto que con un git status, te dice en que tema estas trabajando, pero mucho mejor que te lo informe directamente el prompt. Para hacer esto, sigue estos simples pasos
:EXPORT_DATE: 2019-01-29 16:15 
:CATEGORY: bash
:TAG:      terminal
:END:
Una vez te familiarizas con git, comienzas a crear ramas y llega un momento en el que vas un poco perdido, sin saber bien donde estás.  
Es cierto que con un *git status*, te dice en que tema estas trabajando, pero mucho mejor que te lo informe directamente el prompt. Para hacer esto, sigue estos simples pasos:

** Descargando .git-prompt.sh
Descargamos con wget .git-prompt.sh:

=wget https://raw.githubusercontent.com/git/git/master/contrib/completion/git-prompt.sh -O ~/.git-prompt.sh=

** Editamos ~/.bashrc
Vamos al archivo de configuración de bash *~/.bashrc* para editarlo con emacs:

=emacs ~/.bashrc=

Y añadimos el siguiente código:
#+BEGIN_SRC
source ~/.git-prompt.sh
PS1="\n[\[\033[32m\]\w]\[\033[0m\]\$(__git_ps1)\n\[\033[1;33m\]\u\[\033[32m\]$ \[\033[0m\]"
#+END_SRC

** Personalizando
Aquí te dejo esta tabla, por si quieres personalizar a tu gusto un poco mas el prompt:

*** Texto

#+BEGIN_SRC 
 Usuario, nombre de host y su color de visualización = \u@\h \[\033[32m\]               
 Directorio de trabajo actual y su color de visualización = \w\[\033[33m\]                  
 Nombre de rama de git y su color de visualización = \$(parse_git_branch)\[\033[00m\] 
#+END_SRC

*** Colores

#+BEGIN_SRC 
 Rojo = \[\033[0;31m\]  
 Amarillo = \[\033[0;33m\]  
 Verde = \[\033[0;32m\]" 
 Sin color = \[\033[0m\]"    
#+END_SRC


* Comprimir archivos de forma automatizada en rar a 1.4Gb, para subirlos a Telegram u otra nube pública 
:PROPERTIES:
:TITLE:    Comprimir archivos de forma automatizada en rar a 1.4Gb, para subirlos a Telegram u otra nube pública
:EXPORT_FILE_NAME: Comprimir archivos de forma automatizada en rar para subirlos a telegram u otra nube publica
:DESCRIPTION: Telegram nos proporciona una nube ilimitada... pero con limitaciones. Telegram permite subir archivos que no superen los 1.5Gb y eso puede ser una limitación a subir vídeos domésticos en 4K o incluso alguna distro. Para solucionar este problema, podemos comprimir los archivos en rar y trocearlos
:EXPORT_DATE: 2019-01-29 22:15 
:CATEGORY: bash
:TAG:      telegram
:END:
Telegram nos proporciona una nube ilimitada... pero con limitaciones. Telegram permite subir archivos que no superen los 1.5Gb y eso puede ser una limitación a subir vídeos domésticos en 4K o incluso alguna distro. Para solucionar este problema, podemos comprimir los archivos en rar y trocearlos. Después desde Telegram Desktop los podremos subir sin problemas. Tengo constancia de gente que ha subido archivos de hasta 2Gb, pero en este artículo, ya que no hay limitación en el número de archivos a subir, vamos a limitar a 1,4Gb el tamaño. Este artículo no solo vale para Telegram, Box.com también tiene limitación a 50mb, así que cambiando el número del comando, podrás dividir el archivo al tamaño que desees.

El Objetivo de este artículo, no solo es el aprender a trocear estos, sino también, como a mi me gusta, automatizar esta tarea. Así que en la primera parte, trocearemos archivos que están dentro de una carpeta y en la segunda, trocearemos archivos que están dentro de subcarpetas.

** Instalando rar

Para poder crear archivos rar, necesitamos instalar rar:

=sudo apt install rar=


unrar nos permitirá descomprimir los archivos, así que también lo instalaremos

=sudo apt install unrar=


** Comprimir archivos que estén dentro de una carpeta
Nos situaremos en la carpeta que contenga los archivos superiores a 1.4Gb y ejecutaremos este comando:
#+BEGIN_SRC
for directorio in *; do rar a -va1400m "${directorio%/}.rar" -r "$directorio" ; done
#+END_SRC
Como resultado, tendremos archivos con un tamaño máximo de 1.4Gb, con el nombre del archivo original y numerados.


** Comprimir archivos que estén dentro de subcarpetas
En este caso, vamos a comprimir archivos ubicados en subcarpetas y que su tamaño también superen los 1,4Gb. Nos situaremos en la carpeta raiz de estas subcarpetas y ejecutaremos el comando:
#+BEGIN_SRC
for directorio in */; do rar a -va1400m "${directorio%/}.rar" -r "$directorio" ; done
#+END_SRC
Del mismo modo que en el caso anterior, tendremos los archivos troceados, renombrados y numerados, en la carpeta que estamos situados.

** Reconstruir el archivo original 
Teniendo todos los archivos que previamente habíamos troceado, ahora vamos a transformarlo en el archivo original. Para ello, tenemos que tener instalado *unrar* como comenté al principio y tanto desde la interfaz gráfica, como la terminal, necesitamos que todos los archivos estén en la misma carpeta. Nos situaremos dentro de esta, descomprimiremos el número 1 y unrar se encargará de ir uniendo los trozos y devolvernos el archivo original.

=unrar x archivo.rar=

=unrar x archivo.rar /ruta_donde_enviar_el_archivo= 

Espero que os haya gustado este artículo y a darle caña a la terminal


* Crear Alias 
:PROPERTIES:
:TITLE:    Crear Alias
:EXPORT_FILE_NAME: Crear Alias
:DESCRIPTION: Para facilitar la introducción de comandos largos y complejos, que son difíciles de recordar o simplemente porque utilizamos comandos repetitivos, utilizaremos los alias. Los alias son una palabra que introduciremos en la terminal y bash lo interpretará como una línea de comando
:EXPORT_DATE: 2019-01-31 21:15 
:CATEGORY: bash
:TAG:      terminal
:END:
Para facilitar la introducción de comandos largos y complejos, que son difíciles de recordar o simplemente porque utilizamos comandos repetitivos, utilizaremos los *alias*. Los alias son una palabra que introduciremos en la terminal y bash lo interpretará como una línea de comando.
** Crear Alias
Para crear el alias, editaremos el archivo *.bashrc*
*/home/usuario/.bashrc*
#+BEGIN_SRC 
sudo nano /home/usuario/.bashrc
#+END_SRC

Al final del contenido de este archivo, iremos introduciendo los alias así:
#+BEGIN_SRC 
alias palabra='comando'
#+END_SRC
** Ejemplo de Alias
Si añadimos esta línea en Ubuntu, cada vez que escribamos en la terminal *actualizar*, se ejecutará los comandos para actualizar y además al final aparecerá un mensaje de: "Sistema Operativo Actualizado"
#+BEGIN_SRC
alias actualizar='sudo apt update && sudo apt upgrade && clear && echo "Sistema Operativo Actualizado"'
#+END_SRC

Con una simple palabra, hemos actualizado nuestro Ubuntu. Practica y diviértete creando *alias*
* OrgMode: Buscar solo en las Cabeceras
:PROPERTIES:
:TITLE:    OrgMode: Buscar solo en las Cabeceras
:EXPORT_FILE_NAME: orgmode Buscar solo en las Cabeceras
:DESCRIPTION: Tomar muchas notas, es muy sencillo, lo complicado es después encontrarlas. Cuando decides el crear un único archivo orgmode para tomar tus notas y este crece de forma desmesurada, empiezas a tener problemas cuando quieres localizar notas que sabes que has tomado, pero mediante una búsqueda sencilla por palabras, aparecen cientos de resultados
:EXPORT_DATE: 2019-02-01 21:45 
:CATEGORY: emacs
:TAG:      orgmode
:END:

Tomar muchas notas, es muy sencillo, lo complicado es después encontrarlas. Cuando decides el crear un único archivo orgmode para tomar tus notas y este crece de forma desmesurada, empiezas a tener problemas cuando quieres localizar notas que sabes que has tomado, pero mediante una búsqueda sencilla por palabras, aparecen cientos de resultados.

Lo ideal sería poder buscar palabras solo en la cabeceras y no a lo largo del orgmode. En este [[https://mentat.za.net/blog/2016/12/15/org-mode-header-search/][Post de https://mentat.za.net]], explica como hacer búsqueda solo en las cabecera de primer nivel. Yo, tal como tengo estructuradas mis notas, necesitaba que buscara en todas las cabeceras. Así que he hecho una pequeña modificación al código y aquí os explico el resultado.

** Búsqueda en  cabeceras de mi orgmode

Pensé en replicar tantas veces como fuera necesario, la línea '(setq unread-command-events (listify-key-sequence "^* "))', e ir añadiendo Cabeceras, pero solo me ha bastado una, como aparece en esta cajetilla de código, para que entienda emacs que debe buscar en todas las Cabeceras. No me parece que sea una forma correcta, pero... Funciona!!!!

Añade en *init.es* o *.emacs*, las siguientes líneas:
#+begin_src 
(defun stefan/isearch-heading ()
  (interactive)
  (setq unread-command-events (listify-key-sequence "^* "))
  (setq unread-command-events (listify-key-sequence "^** "))
  (isearch-mode t t nil t))


(defun org-mode-keys ()
  (interactive)
  (local-set-key (kbd "C-c h") 'stefan/isearch-heading)
)
(add-hook 'org-mode-hook 'org-mode-keys)
#+end_src
** Hacer Búsquedas
Para buscar una palabra que estará en cualquiera de las cabeceras, pulsaremos las teclas *C-c h*. Recuerda que podrás personalizar el atajo que desees cambiando este en el código. 

Una vez hecha la primera búsqueda, si tienes mas cabeceras con la misma palabra que deseas buscar, debes de pulsar *C-s* todo el rato, ara ir avanzando a lo largo de las coincidencias

Tengo que decir que el único punto negativo, es que encuentra la palabra, siempre que sea la primera que aparece en el título de la cabecera. Si está a lo largo del título, no la encuentra. De ahí, que en el código aparece "^*". Es una cosa que tenemos que tener en cuenta cuando creemos nuestras notas. 
** Buscar en Cabeceras de Primer Nivel
Código para solo Buscar en cabeceras de primer nivel:
#+begin_src
(defun stefan/isearch-heading ()
  (interactive)
  (setq unread-command-events (listify-key-sequence "^* "))
  (isearch-mode t t nil t))


(defun org-mode-keys ()
  (interactive)
  (local-set-key (kbd "C-c h") 'stefan/isearch-heading)
)
(add-hook 'org-mode-hook 'org-mode-keys)
#+end_src
* Cambiar, mover ruta y contraseña de usuario en tu Raspberry Pi
:PROPERTIES:
:TITLE:    Cambiar, mover ruta y contraseña de usuario en tu Raspberry Pi
:EXPORT_FILE_NAME: Cambiar  mover ruta y contrasena de usuario en tu Raspberry Pi
:DESCRIPTION: En este artículo, vamos a ver como cambiar el usuario y contraseña así como la ruta del usuario, en nuestra raspberry
:EXPORT_DATE: 2019-02-01 23:45 
:CATEGORY: raspberry
:TAG:      raspberry
:END:


Vamos a cambiar el usuario "Pi", por defecto, por el usuario que deseemos, cambiando la carpeta /home/pi por /home/Nuevo_usuario

** Habilitando el usuario root 
Vamos a habilitar el usuario root, que por defecto esta deshabilitado

=sudo passwd root=

Ahora deberemos habilitar el acceso a root desde ssh:
Buscaremos la sección *#Authentication:* y en PermitRootLogin, cambiaremos el valor que haya a continuación por yes.
#+BEGIN_SRC 
#PermitRootLogin prohibit-password
PermitRootLogin yes
#+END_SRC
Quitar el "#" para que surja efecto.

=sudo nano /etc/ssh/sshd_config=

Reiniciamos el servidor ssh *en caso de problemas también la raspberry*

=sudo service ssh restart=

*En caso de tener algún servicio instalado, detener todos los servicios*

** Entrando como root
*Entramos por ssh como root* (salimos de la sesión actual y entramos como root) y vamos a cambiar el nombre de usuario por el que deseemos

=sudo usermod -l nuevo_usuario pi -md /home/nuevo_usuario=

El usuario Pi, seguirá en la máquina. Cambiaremos este por nuestro nuevo usuario:

=sudo groupmod -n nuevo_ de_grupo  pi=

Salimos del ssh y nos logueamos con el nuevo nombre de usuario

Deshabilitamos root, quitando la contraseña de root

=sudo passwd –l root=

** Cambiar contraseña

=passwd=
Nos pedirá la nueva contraseña y que la repitamos.
* Instalar Docker en Raspberry Pi con Raspbian
:PROPERTIES:
:TITLE:    Instalar Docker en Raspberry Pi con Raspbian
:EXPORT_FILE_NAME: Instalar Docker en Raspberry Pi con Raspbian
:DESCRIPTION: En los repositorios de Raspbian, esta disponible el paquete Docker. Aún así, el método de instalación que no te dará errores y funcionará sin ningún problema, es este
:EXPORT_DATE: 2019-02-03 19:45 
:CATEGORY: docker
:TAG:      raspberry,raspbian
:END:

En los repositorios de Raspbian, esta disponible el paquete Docker. Aún así, el método de instalación que no te dará errores y funcionará sin ningún problema, es este.
** Instala primero algunos paquetes que necesitamos
=sudo apt install apt-transport-https ca-certificates curl gnupg2 software-properties-common=

** Obtener la clave de firma Docker para paquetes

=sudo curl -fsSL https://download.docker.com/linux/$(. /etc/os-release; echo "$ID")/gpg | sudo apt-key add -=

** Añadimos los repositorios oficiales
#+BEGIN_SRC 
sudo echo "deb [arch=armhf] https://download.docker.com/linux/$(. /etc/os-release; echo "$ID") \
     $(lsb_release -cs) stable" | \
    sudo tee /etc/apt/sources.list.d/docker.list
#+END_SRC
** Instalamos Docker
#+BEGIN_SRC 
sudo apt update
sudo apt install docker-ce
#+END_SRC
** Iniciamos Docker y lo habilitamos para que se inicie al reiniciar
#+BEGIN_SRC 
sudo systemctl enable docker
sudo systemctl start docker
#+END_SRC

** Crear el grupo Docker, para no tener que poner sudo
#+BEGIN_SRC 
sudo groupadd docker
sudo usermod -aG docker $USER
#+END_SRC
Salir de la terminal y volver a entrar
** Instalar Portainer
 
=docker run -d --name=Portainer --restart=always -p 9000:9000 -v /var/run/docker.sock:/var/run/docker.sock portainer/portainer=
* Instalando una Dokuwiki en 4 pasos
:PROPERTIES:
:TITLE:    Instalando una Dokuwiki en 4 pasos
:EXPORT_FILE_NAME: Instalando una Dokuwiki en 4 pasos
:DESCRIPTION: Dokuwiki puede servirnos tanto para tomar nuestras notas, como previsualizar y editar contenido generado por nuestros scripts. En este post os explico como instalar Dokuwiki en tan solo 4 pasos. En este post, doy por hecho que tienes instalado apache2.
:EXPORT_DATE: 2019-02-06 15:15 
:CATEGORY: servidor
:TAG:      raspberry
:END:
[[./images-blog/dokuwiki.png]]


Dokuwiki puede servirnos tanto para tomar nuestras notas, como previsualizar y editar contenido generado por nuestros scripts.
En este post os explico como instalar Dokuwiki en tan solo 4 pasos. Doy por hecho que tienes instalado apache2.

=sudo apt install apache2=

Lo bueno que tiene dokuwiki, es que no tenemos que instalar base de datos y todas nuestras entradas están en formato texto plano.
** Descargando Dokuwiki 
Hay Versiones estables y no estables. Descargamos con wget, por ejemplo, la versión estable copiando el link de la ruta desde la web de [[https://www.dokuwiki.org/dokuwiki][DokuWiki]].

Nos situamos en  =/var/www/html/=, raiz de nuestro servidor web y descargamos ahí el archivo comprimido con *wget*:

Si no tenemos permisos, podremos descargarlo utilizando *sudo*. Posteriormente, para descomprimir la carpeta, también tendremos que usarlo. =sudo wget ...=, =sudo tar ...=, =sudo mv ...=

=wget https://download.dokuwiki.org/src/dokuwiki/dokuwiki-stable.tgz=

** Descomprimamos
Descomprimimos el archivo descargado. Si no es este el nombre, utiliza el nombre del archivo.

=tar -xzvf dokuwiki-stable.tgz=

Renombra la carpeta con el nombre que desees, yo en mi caso, le podré *dokuwiki*:

=mv dokuwiki-stable/ dokuwiki/=

Ahora vamos a dar permisos de visualización y edición desde el navegador

=sudo chown -R www-data:www-data /var/www/html/dokuwiki=

** Dando el último paso
Accedemos desde el navegador web, a la ip de nuestro servidor y la siguiente ruta:
http://ip/dokuwiki/install.php

Rellenamos los datos de administrador y pulsamos al final para que se inicie la instalación.

Elimina el archivo *install.php*

** Habilitar código embebido html y php
Para poder ver código embebido en html en nuestra dokuwiki, como vídeos de Youtube,etc...  accederemos a traves de la cuenta de administrador a:

Administrar -> Parámetros de Configuración

  
* Papelera Reciclaje desde la Terminal
:PROPERTIES:
:TITLE:    Papelera Reciclaje desde la Terminal
:EXPORT_FILE_NAME: Papelera Reciclaje desde la Terminal
:DESCRIPTION: Cuando utilizamos cualquier tipo de escritorio con interfaz gráfica y borramos un archivo, como sabéis, este archivo en realidad no ha sido borrado, sino que ha sido movido a la papelera. Esto no sucede así cuando utilizamos nuestra terminal. Cuando borras el archivo desde la terminal, lo borras para siempre. Hoy os traigo una herramienta que en lugar de hacer *rm* y eliminarlo para siempre, nos va a llevar este archivo a la papelera. Así mismo, mediante una serie de comandos, nos va a permitir el gestionar todo el contenido de nuestra papelera desde la terminal.
:EXPORT_DATE: 2019-02-07 17:15 
:CATEGORY: bash
:TAG:      terminal
:END:

[[./images-blog/papelera.jpg]]



Cuando utilizamos cualquier tipo de escritorio con interfaz gráfica y borramos un archivo, como sabéis, este archivo en realidad no ha sido borrado, sino que ha sido movido a la papelera. Esto no sucede así cuando utilizamos nuestra terminal. Cuando borras el archivo desde la terminal, lo borras para siempre. Hoy os traigo una herramienta que en lugar de hacer *rm* y eliminarlo para siempre, nos va a llevar este archivo a la papelera. Así mismo, mediante una serie de comandos, nos va a permitir el gestionar todo el contenido de nuestra papelera desde la terminal.
** ¿Donde están los archivos de mi Papelera?
Todos los archivos que eliminamos por interfaz gráfica, van a la papelera. La ruta de esta, es:

=~/.local/share/Trash/files=
** Instalando trash-cli
La instalación de trash-cli, es muy simple, ya que está en los repositorios oficiales:

=sudo apt install trash-cli=

** Tabla de comandos
| trash-put     | Enviar archivos a la Papelera                |
| trash-empty   | Vaciar la papelera                           |
| trash-list    | Listar archivos que hay en la papelera       |
| trash-restore | Restaura un archivo de la papelera           |
| trash-rm      | Elimina archivos individuales de la papelera
** Buscar un Archivo en la Papelera
Si combinamos trash-cli con grep, podremos buscar archivos y carpetas que hay en nuestra papelera, mediante el nombre

=trash-list | grep foo=


También podriamos jugar con nuestro comandos favoritos, como conocer cuantos archivos y carpetas tenemos:

=trash-list | wc -l=

** Eliminar solo los archivos que coincidan con un patrón:
Aquí, por ejemplo, eliminaremos todos los archivos con extensión .txt

=trash-rm \ *.txt=

** Eliminar en función de los dias
Eliminar los archivos enviados a la papelera los últimos 10 dias.

=trash-empty 10=

** ¿Puedo alias rm a trash-put?
Si no me acuerdo de lo que hice ayer, menos me voy a acordar de esta magnífica aplicación. Así que para no borrar de una forma drástica mis archivos o carpetas y hacer uso de esta aplicación, he sustituido mediante el archivo de configuración *.bashrc*, que cuando ejecute el comando *rm*, en realidad ejecute el comando *trash-put* para que lo envie a la papelera.

Para hacer esto, vamos ha hacer uso de los alias:

Con tu editor de texto favorito en terminal, en este caso utilizaremos nano, añadiremos al final esta línea:

=nano ~/.bashrc=

#+BEGIN_SRC 
alias rm='trash-put'
#+END_SRC

Ahora cada vez que hagamos un *rm*, enviará los archivos o carpetas a la papelera.


Otra opción, sería el borrar los archivos mediante cron, programando periódicamente el borrado cada x días
** Conclusión
Como veis, gracias a esta aplicación y a nuestro ingenio con la terminal, podemos automatizar y tener mas controlados nuestros archivos. 

Disfrutar de la terminal 😜


- [[https://github.com/andreafrancia/trash-cli][Repositorio]]
 
* No todo es echo. También existe printf 
:PROPERTIES:
:TITLE:    No todo es echo. También existe printf
:EXPORT_FILE_NAME: No todo es echo Tambien existe printf
:DESCRIPTION: Cuando hacemos scritps en bash, habitualmente utilizamos echo para imprimir o mostrar el resultado a través de la terminal. Si es un resultado simple, en principio no hay ningún problema. Los problemas vienen cuando utilizamos comillas dobles, simples, comillas dentro de una variable, etc... para poder previsualizar sin errores, necesitamos dar escape a las comillas. Esto no es del todo simple y puede frustrar. Para solucionar este problema, podemos utilizar printf.
:EXPORT_DATE: 2019-02-08 22:15 
:CATEGORY: bash
:TAG:      terminal
:END:

Cuando hacemos scritps en bash, habitualmente utilizamos *echo* para imprimir o mostrar el resultado a través de la terminal. Si es un resultado simple, en principio no hay ningún problema. Los problemas vienen cuando utilizamos comillas dobles, simples, comillas dentro de una variable, etc... para poder previsualizar sin errores, necesitamos dar escape a las comillas. Esto no es del todo simple y puede frustrar. Para solucionar este problema, podemos utilizar printf.

** Iniciandonos con printf

printf es mucho mas simple que echo, vamos a comenzar con algunos simples ejemplos:


#+BEGIN_SRC 
$ printf "Hola Mundo"
Hola Mundo
#+END_SRC
** Salto de línea

Del mismo modo que *echo*, podemos hacer salto de líneas. Vamos a ver varios ejemplos:


#+BEGIN_SRC 
$ printf "%s\n" "Hola Mundo"
Hola Mundo
#+END_SRC


#+BEGIN_SRC 
$ printf "Hola \nMundo"
Hola
Mundo
#+END_SRC



#+BEGIN_SRC 
$ printf "%s\n" "Hola" "Mundo"
Hola
Mundo
#+END_SRC



#+BEGIN_SRC 
$ printf "%*s\n" $(tput cols) "Hola Mundo!"
Hola
Mundo
!
#+END_SRC

** Imprimir al final de la línea 

Ahora vamos a desplazar la línea al final del margen derecho:


#+BEGIN_SRC 
$ printf "%*s\n" $(tput cols) "Hola Mundo!"

                                 Hola Mundo!
#+END_SRC


** Llamada de Fechas, host, rutas  

Podemos llamar diferentes formatos de fecha, host, rutas,...


#+BEGIN_SRC 
$ printf 'Esta es la semana %(%U/%Y)T.\n' -1
Esta es la semana 05/2019.
#+END_SRC

Mostrando la fecha y host:


#+BEGIN_SRC 
$ printf "%s:%s\n" "$(date)" "$(hostname)"
vie feb  8 22:16:26 CET 2019:angel
#+END_SRC


Ruta de mi carpeta home:


#+BEGIN_SRC 
$ printf "La ruta de mi home es %s.\n" $HOME
La ruta de mi home es /home/angel.
#+END_SRC

Añadiendo el nombre con el que nos hemos logeado en la sesión:


#+BEGIN_SRC 
$ printf "Hola, Soy %s.\n" $LOGNAME
Hola, Soy angel.
#+END_SRC


Fecha y hora:


#+BEGIN_SRC 
$ printf "%(%m-%d-%Y %H:%M:%S)T\n" $(date +%s)
02-08-2019 21:10:35
#+END_SRC


Tabla con el código del formato de fecha:


| Código de Formato | Descripción                                                                       |
|-------------------+-----------------------------------------------------------------------------------|
| %%                | un% literal                                                                       |
| %a                | el nombre abreviado del día de la semana de locale (por ejemplo, Lun)             |
| %A                | el nombre completo del día laborable de la localidad (por ejemplo, domingo)       |
| %b                | el nombre abreviado del mes de la localidad (por ejemplo, enero)                  |
| %B                | el nombre completo del mes del local (por ejemplo, enero)                         |
| %c                | Fecha y hora del local (por ejemplo, jue 3 de marzo 23:05:25 2005)                |
| %C                | siglo; como% Y, excepto omitir los últimos dos dígitos (por ejemplo, 20)          |
| %d                | día del mes (por ejemplo, 01)                                                     |
| %D                | fecha; igual que% m /% d /% y                                                     |
| %e                | día del mes, espacio acolchado; igual que% _d                                     |
| %F                | fecha completa igual que% Y-% m-% d                                               |
| %g                | los dos últimos dígitos del año del número de semana ISO (ver% G)                 |
| %G                | año del número de semana ISO (ver% V); Normalmente útil solo con% V               |
| %h                | igual que% b                                                                      |
| %H                | hora (00..23)                                                                     |
| %I                | hora (01..12)                                                                     |
| %j                | día del año (001..366)                                                            |
| %k                | hora, espacio rellenado (0..23); igual que% _H                                    |
| %l                | hora, espacio acolchado (1..12); igual que% _I                                    |
| %m                | mes (01..12)                                                                      |
| %M                | minuto (00..59)                                                                   |
| %n                | una nueva linea                                                                   |
| %N                | nanosegundos (000000000..999999999)                                               |
| %p                | el equivalente local de AM o PM; en blanco si no se conoce                        |
| %P                | como% p, pero minúscula                                                           |
| %q                | trimestre del año (1..4)                                                          |
| %r                | el reloj de 12 horas del local (por ejemplo, 11:11:04 PM)                         |
| %R                | Hora y minuto de 24 horas; igual que% H:% M                                       |
| %s                | segundos desde 1970-01-01 00:00:00 UTC                                            |
| %S                | segundo (00..60)                                                                  |
| %t                | una pestaña                                                                       |
| %T                | hora; igual que% H:% M:% S                                                        |
| %u                | día de la semana (1..7); 1 es lunes                                               |
| %U                | Número de la semana del año, con el domingo como primer día de la semana (00..53) |
| %V                | Número de semana ISO, con el lunes como primer día de la semana (01..53)          |
| %w                | día de la semana (0..6); 0 es domingo                                             |
| %W                | Número de la semana del año, con el lunes como primer día de la semana (00..53)   |
| %x                | Representación de la fecha de la localidad (por ejemplo, 31/12/99)                |
| %X                | Representación del tiempo del local (por ejemplo, 23:13:48)                       |
| %y                | los dos últimos dígitos del año (00..99)                                          |
| %Y                | año                                                                               |
| %z                | + hhmm zona horaria numérica (por ejemplo, -0400)                                 |
| %:z               | + hh: mm zona horaria numérica (por ejemplo, -04: 00)                             |
| %::z              | + hh: mm: ss zona horaria numérica (por ejemplo, -04: 00: 00)                     |
| %:::z             | zona horaria numérica con: a la precisión necesaria (por ejemplo, -04, +05: 30)   |
| %Z                | abreviatura alfabética de la zona horaria (por ejemplo, EDT)                      |






** Editar texto 

Cortar Texto:


#+BEGIN_SRC 
$ printf "%.*s" 12 "Muestra solo las cinco primeras letras"
Muestra solo
#+END_SRC




#+BEGIN_SRC 
$ printf "Me llamo \"%s\".\nEs un placer conocerte." "Angel"
Me llamo "Angel".
Es un placer conocerte.
#+END_SRC


Indentado:

#+BEGIN_SRC 
$ printf "%*s\n" 25 "Hola Mundo"

               Hola Mundo
#+END_SRC

** Números


#+BEGIN_SRC 
$ printf "2 + 2 son %d\n" $((2+2))
2 + 2 son 4
#+END_SRC



#+BEGIN_SRC 
$ printf "Aquí en solo %d pondremos estos %d valores.\n\ndoble salto de línea" 1 2

Aquí en solo 1 pondremos estos 2 valores.

doble salto de línea
#+END_SRC


Creando 2 columnas:


#+BEGIN_SRC 
$ printf "%-10d %-10d\n" 1 500 2 550

1          500       
2          550
#+END_SRC


** Conclusión
Como podéis ver, printf tiene muchísimas posibilidades y aquí solo he descrito unas pocas. Si os soy sincero, soy un clásico y tiro por comandos como *date* y *echo*. Pero lo que si que es cierto, que si llegas a un momento de desesperación con las comillas en un script, printf es una gran solución.

** Fuentes
- https://www.computerhope.com/unix/uprintf.htm
- https://wiki.bash-hackers.org/commands/builtin/printf
- https://www.cyberciti.biz/faq/unix-linux-getting-current-date-in-bash-ksh-shell-script/
* 2 Archivos de configuración, un Emacs
:PROPERTIES:
:TITLE:    2 Archivos de configuración, un Emacs
:EXPORT_FILE_NAME: 2 Archivos de configuracion un Emacs
:DESCRIPTION: Como sabéis, podemos utilizar Emacs tanto con interfaz gráfica como vía terminal. La verdad es que utilizo las dos versiones, pero cuando utilizo la versión vía terminal, quiero que sea ligera y muy rápida, pero sin perder cierta personalización como el acceso a los archivos .org, resaltar la sintaxis, corrector ortográfico... Para la interfaz gráfica, dejo la totalidad de paquetes instalados y eso hace que el arranque sea un poquito mas lento, pero con la totalidad de servicios disponibles como elfeed, temas, etc... En este post voy a explicaros como utilizo mis dos archivos de configuración init.el de Emacs, para las dos versiones
:EXPORT_DATE: 2019-02-08 23:15 
:CATEGORY: emacs
:TAG:      orgmode
:END:

 Como sabéis, podemos utilizar Emacs tanto con interfaz gráfica como vía terminal. La verdad es que utilizo las dos versiones, pero cuando utilizo la versión vía terminal, quiero que sea ligera y muy rápida, pero sin perder cierta personalización como el acceso a los archivos .org, resaltar la sintaxis, corrector ortográfico... Para la interfaz gráfica, dejo la totalidad de paquetes instalados y eso hace que el arranque sea un poquito mas lento, pero con la totalidad de servicios disponibles como elfeed, temas, etc... En este post voy a explicaros como utilizo mis dos archivos de configuración *init.el* de Emacs, para las dos versiones.

** Archivo de configuración con Interfaz gráfica
Para la interfaz gráfica, dejo el archivo en la ruta por defecto. =~/.emacs.d/init.el= 
** Archivo de configuración versión terminal
En breve, publicaré un pequeño script en bash con el que gestiono mis *dotfile*. En esta carpeta donde los guardo, que la tengo sincronizada mediante syncthing con todos mis dispositivos, tengo mi archivo de configuración para la versión de terminal.

Lo que hago es crear un nuevo alias en *.bashrc*, llamado "e", para que cuando introduzca esta letra en la terminal, ejecute Emacs versión terminal con el archivo de configuración en mi carpeta de dotfiles:

#+BEGIN_SRC 
printf "alias e='emacs -nw -q --load ~/dotfile/emacs/init_terminal.el'" >> ~/.bashrc
#+END_SRC 

Mediante esta simple línea de terminal, añadirá el nuevo alias a *.bashrc*.

Crea un nuevo archivo de configuración y personaliza este. Personaliza también a tu gusto tanto el nombre del alias como la ruta del archivo de configuración.

Ya tienes Emacs con dos personalizaciones similares, pero diferentes 😜

A Disfrutar a tope con Emacs!!!
* Servidor Jabber/XMPP en tu Raspberry mediante Docker y Dockerfile
:PROPERTIES:
:TITLE:    Servidor ejabberd/xmpp en tu Raspberry mediante Docker y Dockerfile
:EXPORT_FILE_NAME: Servidor ejabberd xmpp en tu Raspberry mediante Docker y Dockerfile
:DESCRIPTION: En el Podcast, os he hablado muchas veces de las virtudes de docker: sencillez, seguridad, etc... En el artículo de hoy, voy a instalar un servidor ejabberd para raspberry, que no he encontrado en el Docker Hub y porque no decirlo, para los mas paranoicos, porque no instalarlo paso a paso
:EXPORT_DATE: 2019-02-10 22:25 
:CATEGORY: docker
:TAG:      debian,alpinelinux,mensajeria,docker
:END:

[[./images-blog/ejabberd.png]]


En el Podcast, os he hablado muchas veces de las virtudes de docker: sencillez, seguridad, etc... En el artículo de hoy, voy a instalar un servidor ejabberd para raspberry, que no he encontrado en el Docker Hub y porque no decirlo, para los mas paranoicos, porque no instalarlo paso a paso...

El Dockerfile es una archivo en texto plano que nos permite, del mismo modo que hacemos en un script, escribir línea a línea todos los comandos que queremos que se ejecuten en el momento de crear el Docker. Partimos en la primera línea descargando de un sistema operativo y después sucesivamente se ejecutaran todos esos comandos, cerrando por último nuestra imagen.

Vamos a crear un servidor ejabberd de mensajería, partiendo de una distro debian para arm32v7.


En próximos posts explicaré como hacer Dockers partiendo de una distro que tan solo ocupa 5 Mb, Alpine Linux. Pero para ejabberd, no hay una versión estable del servicio para arm. Así que... Vamos a utilizar una debian que es lo que conozco bien.

** Dockerfile

Crea con tu editor texto favorito, un archivo sin extensión llamado *Dockerfile* y dentro copiar este contenido.

#+begin_src 
FROM arm32v7/debian:latest
MAINTAINER angel <ugeekpodcast@gmail.com>

RUN apt-get -y update; \
    apt-get -y upgrade; \
    apt-get -y install apt-utils \
    ejabberd; 


EXPOSE 5280
EXPOSE 5222
EXPOSE 5269

VOLUME /etc/ejabberd/


ENTRYPOINT service ejabberd start && /bin/bash
CMD ["bash"]
#+end_src

- La primera línea, *FROM*, nos descargará de Docker Hub la distro debian para arm32v7.
- *MAINTAINER*, son los datos de quien va a mantener el contenedor. En este caso no es necesario, ya que mi intención no es subirlo al Docker Hub, pero vamos a ponerlo.
- *RUN*, Comando que se ejecutaran del mismo modo que un script en bash. Actualizamos repositorios e instalamos todo aquello que necesitamos para crear nuestro servidor.
- *EXPOSE*, son los puertos que quedarán abiertos en el contenedor.
- *VOLUME*, es la carpeta del contenedor que deseamos que quede accesible desde fuera del contenedor. Esto es ideal en este caso para dejar el archivo de configuración fuera del contenedor y así si después actualizamos el Docker o se rompe, restaurando a partir de la imagen. Dejando el archivo de configuración, todo funcionará como si no hubiera pasado nada.
- *ENTRYPOINT*, Comando que ejecutaremos una vez montado el contenedor.


** Creando la Imagen

Nos situaremos en la carpeta donde está el archivo *Dockerfile* y ejecutaremos el siguiente comando:

=docker build -t ejabberd_imagen:dockerfile .=

** Veamos si se ha creado la imagen
Con este comando veremos todas las imágenes que tenemos en el servidor. La última, corresponderá la imagen que hemos creado:

=docker images=

Tenemos una nueva imagen de 155Mb con el nombre que habíamos puesto!!!
#+begin_src 
REPOSITORY                TAG                 IMAGE ID            CREATED             SIZE
ejabberd_imagen           dockerfile          983bc10a3e5b        47 seconds ago      155MB
#+end_src

** Creando del Contenedor
Ya tenemos nuestra imagen, ahora vamos a crear el contenedor.
A la imagen la nombramos *ejabberd_imagen* y al contenedor, lo pondremos el nombre de *ejabberd*

Solo hay 2 valores que tiene que añadir:
- $USUARIO  : Escribe tu usuario
- $IMAGE_ID : Escribe el número de *IMAGE ID*, que te apareció en el paso anterior.

=docker run -dti --name ejabberd --restart=unless-stopped -p 5280:5280 -p 5222:5222 -v /home/$USUARIO/docker/ejabberd_config:/etc/ejabberd/  $IMAGE_ID=

En la carpeta =/home/$USUARIO/docker/ejabberd_config=, encontraremos el archivo de configuración del servidor.
** Entrar en el Docker
Ahora vamos a entrar al interior del Docker. Una vez dentro de este, estaremos en una versión de debian, con todo lo justo para que funcione nuestro servidor y para que sea del mínimo tamaño.

=docker exec -i -t ejabberd /bin/bash=

ejabberd es el nombre que habíamos dado a nuestro contenedor.
** Vamos a configurar nuestro servidor
Una vez dentro, mediante este comando, daremos nombre al servidor, nombre de administrador y contraseña del mismo.

=dpkg-reconfigure ejabberd=

Es posible que de error. Si es así, pararemos el servidor y lo volveremos a iniciar.

_Detener el servidor_

=service ejabberd stop=

_Iniciar el servidor_

=service ejabberd start=


** Configurando el servidor

Ahora nos conectamos a =https://ip:5280/admin=, que es la web de administración del servicio. Nos pedirá para acceder el nombre del servidor y usuario del administrador, que hemos puesto en el paso anterior.

Nombre de usuario: admin@localhost
Contraseña: password

Archivo de configuración está en: =/etc/ejabberd/ejabberd.yml=

** Añadir usuarios 
Para añadir usuarios desde la interfaz de administración web, seleccionaremos en el menú *Dominios Virtuales* -> *Dominio* -> *Usuarios*.
Ahí, añadiremos nuestros usuarios y sus contraseñas. Esto sería en el caso que únicamente el administrador del servidor, sea el único que permita el registro de usuarios, tal como viene por defecto. También podríamos hacer que cada usuario que quiera, pueda registrarse.


** Aumentar la velocidad de transferencia de archivos. TRAFFIC SHAPERS

Ejabberd/xmpp, no está diseñado para transferir archivos, aún así, notarás que la transferencia de archivos es muy lenta y es debido a que el archivo de configuración tiene limitación en la transferencia por defecto, por si el número de usuarios que van a utilizar el servidor es muy grande. También tiene limitado el tamaño máximo de archivo a compartir. Desmarca mediante *#* o personaliza a tu gusto los parametros en *ejabberd.yml*, Recuerda que puedes acceder desde fuera del contenedor, gracias al volumen que creamos al crear el mismo.

#+begin_src 
shaper:
  ##
  ## The "normal" shaper limits traffic speed to 1000 B/s
  ##
##########  normal: 10000000

  ##
  ## The "fast" shaper limits traffic speed to 50000 B/s
  ##
##########  fast: 50000

##
## This option specifies the maximum number of elements in the queue
## of the FSM. Refer to the documentation for details.
##
#max_fsm_queue: 1000
#+end_src

Podemos personalizar absolutamente nuestro servidor desde este archivo, pero es muy complejo. Visita la web de ejabberd para ver ejemplos y sobretodo, haz una copia del archivo antes de modificarlo. 


** Web ejabberd
- https://www.ejabberd.im/
* Cliente dlna para tu escritorio 
:PROPERTIES:
:TITLE:   Cliente dlna para tu escritorio
:EXPORT_FILE_NAME: Cliente dlna para tu escritorio
:DESCRIPTION: Ya os expliqué como crear tu servidor dlna en raspberry o servidor Linux y como crear listas en m3u para el servidor, ahora tocaría el poder utilizar un cliente dlna en tu escritorio. Tenemos muchas aplicaciones para movil, smart TV,... pero, ¿Para escritorio?, no tendría sentido el montar un servidor multimedia solo para movil, tabletas y Tv. La verdad, es que escasean para escritorio, pero gracias a aplicaciones como Rhythmbox y sus plugins, podemos utilizar dlna de un modo muy sencillo. Aquí os explico como hacerlo
:EXPORT_DATE: 2019-02-16 20:30 
:CATEGORY: servidor
:TAG:      dlna
:END:


[[./images-blog/rhythmbox.png]]

Ya os expliqué como [[https://ugeek.github.io/blog/post/2018-12-27-minidlna.html][crear tu servidor dlna en raspberry o servidor Linux]] y [[https://ugeek.github.io/blog/post/2019-01-02-crear-listas-m3u-para-minidlna-o-vlc.html][como crear listas en m3u para el servidor]], ahora tocaría el poder utilizar un cliente dlna en tu escritorio. Tenemos muchas aplicaciones para movil, smart TV,... pero, ¿Para escritorio?, no tendría sentido el montar un servidor multimedia solo para movil, tabletas y Tv. La verdad, es que escasean para escritorio, pero gracias a aplicaciones como [[https://wiki.gnome.org/Apps/Rhythmbox][Rhythmbox]] y sus plugins, podemos utilizar dlna de un modo muy sencillo. Aquí os explico como hacerlo:

** Instalaremos Rhythmbox

=sudo apt install rhythmbox=

Una vez instalado, en los menús, accederemos a: *Herramientas -> Complementos*, habilitaremos marcando el checklist: *Explorador de medios Grilo*

** Instalando en tu distro
Buscamos los plugins de Grilo en nuestra distro:

=sudo apt search grilo-plugins=

En Ubuntu 18.04, nos aparece *grilo-plugins-0.3*, dependerá la versión de que distro tengamos instalada. Instala la que tengas:

=sudo apt install grilo-plugins-0.3=

Ahora si abrimos Rhythmbox, tendría que aparecer nuestro servidor.

** VLC
[[./images-blog/vlc.png]]

Para los que utilizamos VLC y no nos apetece el instalar o utilizar Rhythmbox, sigue los siguientes pasos:

- Una vez abierto VLC, pulsa *CTRL + L*
- En la columna derecha, bajo *Red Local*, haz click en *Plug’n’Play Universal*
- En la parte derecha, nos aparecerán todos los Servidores dlna disponibles en nuestra red local


* Instalar servicios o aplicaciones con Docker para tu Raspberry o cualquier servidor GNU/Linux
:PROPERTIES:
:TITLE:   Instalar servicios o aplicaciones con Docker para tu Raspberry o cualquier servidor GNU/Linux
:EXPORT_FILE_NAME: Instalar servicios o aplicaciones con Docker para tu Raspberry o cualquier servidor GNU-Linux
:DESCRIPTION: El objetivo del post de hoy, va a ser crear un contenedor con una sola línea de comandos, entrar dentro de este, instalar un servicio o aplicación e iniciarlo. Pero lo mejor de todo, es que vamos a utilizar una distro diferente para nuestro contenedor, creando un servidor con un Ubuntu 18.04 en una Raspberry con sistema operativo Raspbian
:EXPORT_DATE: 2019-02-24 17:30 
:CATEGORY: docker
:TAG:      docker
:END:

[[./images-blog/docker.png]]

El objetivo del post de hoy, va a ser crear un contenedor con una sola línea de comandos, entrar dentro de este, instalar un servicio o aplicación e iniciarlo. Pero lo mejor de todo, es que vamos a utilizar una distro diferente para nuestro contenedor, creando un servidor con un *Ubuntu 18.04* en una Raspberry con sistema operativo *Raspbian*.

De esta manera, podremos acceder a los repositorios de Ubuntu en su última versión, con paquetes totalmente actualizados utilizando Raspbian.

Parece muy complejo, pero es muy sencillo.
** Instalación
Vamos a instalar Docker desde los repositorios oficiales:

=sudo apt install docker=

También lo tenemos disponible en la paquetería snap, así que a dia de hoy, es muy sencilla su instalación.

** Crear el grupo docker, para no tener que poner siempre sudo
Para no tener que utilizar Docker como usuario root y así evitar el tener que poner siempre *sudo*, crearemos el grupo docker y añadiremos los usuarios.
#+BEGIN_SRC 
sudo groupadd docker
sudo usermod -aG docker $USER
#+END_SRC
También es muy útil a nivel de seguridad deshabilitar el usuario root, para iniciar y detener servicios con la sesión del propio usuario o mediante el cron este, programar el encendido y apagado de los contenedores. 

** Creando un contendedor con Ubuntu en su ultima versión
Creando el nuevo contenedor con la última versión de Ubuntu para Raspberry o cualquier arquitectura de procesador y entrando directamente a este contenedor una vez creado:

=docker run -t -i ubuntu:latest /bin/bash=

Para nuestra Raspberry, si queremos, también podemos especificar la arquitectura con la que queremos montar en nuestro contenedor:

=docker run -t -i arm32v7/ubuntu:latest /bin/bash=

La versión *"latest"*, es la 18.04, si queremos utilizar una en concreto, deberemos especificarlo.

Una vez creado el contenedor y dentro de él, podemos salir pulsando =exit= o =Ctrl-d=. Esto dentendrá nuestro contenedor, para que esto no suceda, pulsa =Ctrl+p+q=

** Listar todos los Contenedores de nuestro servidor
Vamos a listar todos los contenedores que tenemos en nuestro servidor, indistintamente si están corriendo ahora o no:

=docker ps -a=

No confundir con ver todos los contenedores que están corriendo ahora mismo en nuestro servidor, que lo haríamos así:

=docker ps=

** Iniciar o detener un contenedor
Super sencillo, con docker *start/stop*:

=docker start nombre_del_contenedor=

=docker stop nombre_del_contenedor=

** Entrar dentro del Docker vía terminal
Para entrar a la terminal de nuestro contenedor, tenemos que ejecutar:
=docker exec -i -t nombre_del_contenedor /bin/bash=

** Ejemplo práctico de todo lo visto. Descargar imagen y crear e iniciar contenedor
Voy a explicar, con el servicio garbera de ejemplo, como descargar la imagen, crear el contenedor e iniciarlo con una única línea de terminal. 

=docker run -t -i --name gerbera -p 1900:1900 -p 49152:49152 -v /home/usuario/docker/gerbera:/etc/gerbera/ -v /media:/root arm32v7/ubuntu:latest /bin/bash=

Vamos a entenderlo:
- Poner un nombre al contenedor que se creará =--name gerbera= El nombre será gerbera
- Crea imagen con la ultima versión de ubuntu con arquitectura para raspberry: =arm32v7/ubuntu:latest=. Si fuera para cualquier arquitectura y que se instale el más adecuado:  =ubuntu:latest=
- Que el contenedor creado, tenga abiertos los puertos 1900 y 49152 =-p 1900:1900 -p 49152:49152=
- Tener 2 carpetas de intercambio de archivos, entre carpetas del servidor y carpetas internas del contenedor =-v /home/usuario/docker/gerbera:/etc/gerbera/ -v /media:/root=

Una vez estemos dentro del contenedor, igual que haríamos si nos hubiéramos conectado a un servidor por ssh, instalaremos e iniciaremos el servicio:

 *Recuerda sustituir "usuario", por tu usuario, no hagas un copia y pega* 😜
** Borrar un contenedor
Si ya has acabado con tus pruebas, voy a explicarte algunos comando muy útiles, como borrar el contenedor, imagenes, etc... que ya no vamos a utilizar:

Detenemos el contentedor:

=docker stop nombre_del_contenedor=

Borramos el contendedor:

=docker rm nombre_del_contenedor=

** Listar y borrar imagenes
Es posible que quieras eliminar la imagen con la que habíamos creado nuestro Docker, para ello, listaremos y borraremos así:

Listar todas las imágenes:

=docker images=

Borrar la imagen (rm"i" de imágen, para recordar):

=docker rmi nombre_de_la_imagen=


** Renombrar Contenedor
En caso que quisieras cambiar el nombre del contenedor, haremos lo siguiente:

=docker rename nombre_actual nombre_nuevo= 

** Conclusiones
Con un poco de práctica, como ves, Docker puede ayudarte a probar, practicar y utilizar servicios o aplicaciones, dentro de estos de un modo muy limpio y sencillo. El punto fuerte es que no vas a romper nada del sistema operativo anfitrión, y además, en el caso de la Raspberry, utilizar aplicaciones a la última que no están disponibles en Raspbian. 
* Simplenote en Emacs
:PROPERTIES:
:TITLE:   Simplenote en Emacs
:EXPORT_FILE_NAME: Simplenote en Emacs
:DESCRIPTION: Simplenote, es una aplicación de notas muy conocida de Software Libre, totalmente multiplataforma y gratuita. Podemos utilizar Simplenote en nuestro navegador web, aplicaciones de escritorio (incluso con paquete snap), Android, iOS... Y lo mejor de todo, podemos utilizarla en Emacs con el paquete simplenote2, disponible en los repositorios de Melpa.
:EXPORT_DATE: 2019-03-10 17:15 
:CATEGORY: emacs
:TAG:      orgmode,emacs
:END:

[[./images-blog/simplenote.png]]


Simplenote, es una aplicación de notas muy conocida de Software Libre, totalmente multiplataforma y gratuita. Podemos utilizar Simplenote en nuestro navegador web, aplicaciones de escritorio (incluso con paquete snap), Android, iOS... Y lo mejor de todo, podemos utilizarla en Emacs con el paquete *simplenote2*, disponible en los repositorios de Melpa.

Simplenote va a permitir la sincronización de nuestras notas en texto plano o markdown por defecto. Pero ya que estamos en Emacs, *voy a habilitar el modo org y tener sincronizado mis archivos orgmode*.

El paquete *simplenote2*, crea una carpeta oculta en la raíz de nuestro Home, llamada *.simplenote2*. Dentro, encontraremos todas nuestras notas de un modo transparente, igual que si fuera una carpeta de sincronización de Dropbox. Así nuestras notas también estarán siempre en nuestro PC.

Si utilizamos Emacs en versión terminal, también podremos utilizar el paquete. Así que ya tenemos aplicación de notas desde nuestra terminal.

Recuerda que una de las virtudes de Simplenote, es compartir nuestras notas o documentos orgmode, tener un control de versiones y colaborar en equipo editando simultaneamente estas, varios usuarios.

Te recomiendo escuchar el Podcast donde hablo de todo esto.
** Instalación
Instalaremos desde Melpa:

=M-x package-install RET simplenote2 RET=
** Configuración
Añadiremos en nuestro archivo de configuración, ya sea *.emacs* o *init.el*, los siguientes requisitos:
#+begin_src 
(require 'simplenote2)
(setq simplenote2-email "email@ejemplo.com")
(setq simplenote2-password "tu_contraseña")
(simplenote2-setup)
#+end_src

Para acceder a la pantalla principal de Simplenote mediante un atajo (C-c C-s), he añadido el siguiente código:

=(global-set-key (kbd "C-c C-s") 'simplenote2-browse)=


Estas líneas son opcionales. Permiten crear mediante atajos: tags, así como empujar o descargar la nota que estamos editando en ese momento. 
#+begin_src 
(add-hook 'simplenote2-note-mode-hook
          (lambda ()
            (local-set-key (kbd "C-c C-t") 'simplenote2-add-tag)
            (local-set-key (kbd "C-c C-c") 'simplenote2-push-buffer)
            (local-set-key (kbd "C-c C-d") 'simplenote2-pull-buffer)))
#+end_src


** Utilizando Simplenote
Para acceder a la pantalla principal de Simplenote sin el atajo antes descrito, introduciremos el comando: 

=M-x simplenote2-browse=

La primera vez que accedas, estará sin contenido, ejecuta en la parte superior *[Sync with server]*, para que descargue tus notas del servidor a la aplicación. Si no añadiste tu correo y contraseña, Simplenote te preguntará por ellas para que lo introduzcas.


A la parte derecha de cada nota, nos aparece *[Delete]*. Si pulsamos para borrar y después pulsamos *[Sync with server]* o sincronizamos pulsando la letra *g* (En el siguiente apartado, aparecen todos estos atajo), actualizará todas las notas y borrará la que habíamos seleccionado, enviándola a la papelera.


Como ves, la interfaz es muy intuitiva, podemos crear nuevas notas, editar o eliminar notas existentes... 

** Atajos
Estando *dentro de la ventana de Simplenote en Emacs*, podremos utilizar los siguientes atajos:

| Tecla | Acción                                                                               |
|-------+--------------------------------------------------------------------------------------|
| g     | sincronizar con el servidor (igual que M-x simplenote2-sync-notes)                   |
| a     | crear una nueva nota                                                                 |
| Enter | nota abierta sobre la linea actual                                                   |
| d     | marca nota en la línea actual para eliminar                                          |
| u     | desmarque la nota en la línea actual para eliminar                                   |
| t     | establecer etiquetas para el filtrado (igual que M-x simplenote2-filter-note-by-tag) |
| '^'   | alternar las condiciones de filtrado de etiquetas entre "AND" y "OR"                 |
| '/'   | establecer regexp para el filtrado                                                   |

** Enviando todo a Simplenote
Si estás en cualquier buffer, fuera de Simplenote, creando una nota o escribiendo cualquier texto, si ejecutamos el siguiente comando, este bufer será enviado en forma de nota a Simplenote.

=M-x simplenote2-create-note-from-buffer=

** Sincronizando las modificaciones
Tal como hacemos en git, podemos empujar la nota actual que estamos editando al servidor o descargarla:
- Empujar nota al servidor: =M-x simplenote2-push-buffer=
- Descargar la nota del servidor. Cuando la nota se modifique localmente, preguntará si la envía al servidor. Si la respuesta es afirmativa, este comando actúa como =M-x simplenote2-push-buffer=: =M-x simplenote2-pull-buffer=

Para salir, utilizaremos =C-u M-x=
** Etiquetas
Simplenote utiliza etiquetas para poder clasificar y posteriormente filtrarlas medieante =M-x simplenote2-filter-notes-by-tag=. Este comando, preguntará el nombre de la etiqueta.

** Creando atajo preestablecido
En Nuestro archivo de configuración *.emacs* o *init.el*, podemos añadir un filtro preestablecido con un atajo de teclado. Ejemplo:

=(setq simplenote2-filter-note-tag-list '("tag1" "tag2" "tag3"))=


** Añadir etiquetas o atributos
Puede establecer etiquetas o atributos para nuevas notas de forma predeterminada utilizando la variable de personalización =simplenote2-create-note-hook=

#+begin_src
(add-hook 'simplenote2-create-note-hook
	  (lambda ()
	    (simplenote2-set-markdown)
	    (simplenote2-add-tag "tag1")))
#+end_src

** Anclar Notas En la parte superior
Para anclar en la parte superior las notas que deseemos, estando dentro de esta nota ejecutaremos el comando: 

=M-x simplenote2-set-pinned=

** Conclusión
Una herramienta fantástica para aquellos que necesitan una aplicación de notas que podemos compartir, trabajar en equipo, tener un control de versiones... Y lo mejor de todo, en texto plano, markdown y en Emacs, habilitando el modo org, orgmode.

Mas Información en el repositorio de simplenote2: https://github.com/alpha22jp/simplenote2.el
* Crea un Bot de Telegram con Bash y una sola línea de Terminal
:PROPERTIES:
:TITLE:   Crea un Bot de Telegram con Bash y una sola línea de Terminal
:EXPORT_FILE_NAME: Crea un Bot de Telegram con Bash y una sola linea de Terminal
:DESCRIPTION: Como ya sabéis, Telegram es de mis aplicaciones favoritas. Y no solo por todas las características a la hora de enviar mensajes, almacenar archivos, etc... si no que gracias a la sencilla api de Telegram, puedo crear mis bots para que notifiquen todo tipo de cosas que suceden en mi raspberry, servidor, pc
:EXPORT_DATE: 2019-03-14 21:30 
:CATEGORY: telegram
:TAG:      bot, telegram,
:END:

[[./images-blog/telegram.jpg]]

Como ya sabéis, Telegram es de mis aplicaciones favoritas. Y no solo por todas las características a la hora de enviar mensajes, almacenar archivos, etc... si no que gracias a la sencilla api de Telegram, puedo crear mis bots para que notifiquen todo tipo de cosas que suceden en mi raspberry, servidor, pc... 

Si, pero... ¿Que nos puede notificar?.

Voy a mostraros algunos ejemplos que yo utilizo:
- Notificación al iniciar un servidor
- Notificación cuando alguien se conecta vía SSH, mostrándome la IP del dispositivo que se conecta
- Cuando ha finalizado la ejecución de un script. Por ejemplo una sicronización con rsync, copia de seguridad...

Gracias a cron, podemos programar mensajes a determinados momentos del día para que nos notifique:
- Consumo de Ram
- Temperatura de la Raspberry
- IP pública de mi red
- Mis tareas pendientes en mi OrgMode

Estos son tan solo unos ejemplos que yo utilizo, pero con un bot de Telegram, puedes hacer tanto como imagines.

Incluso mi Router con OpenWrt, va enviándome mensajes, jejeje   

Durante mucho tiempo he estado utilizando Bots desarrollados en Python, pero en este Post voy a explicaros como hacerlo desde de Bash que es muchísimos más sencillo. De momento vamos a enviar mensajes de Texto.

** Primer paso para crear un Bot
Voy a explicar en sencillos pasos como crear un Bot con [[https://t.me/BotFather][@BotFather]], que es el padre de todos los Bots, creado por Telegram con el fin de facilitar la creación de estos:

- Clicamos este enlace [[https://t.me/BotFather][@BotFather]] e iniciamos el Bot.

- Seleccionamos o escribimos */newbot*. Nos preguntará: ¿Que nombre quieres dar a tu bot?. Escribimos un nombre.

- El Bot nos respone ahora: ¿Que nick quieres usar para este bot?, recuerda que el nick debe de acabar en bot o _bot.
  ejem: @nick_bot, @nickbot,...

- @BotFather ya nos ha creado el bot!!!. Ahora ya tenemos nuestro numero de Token para poder utilizar nuestro bot.


Si escribimos en @BotFather: */setuserpic*, podremos elegir una foto para nuestro bot. Hay muchas mas opciones como añadir una descripción y demas, pero eso ya os lo dejo a vosotros...


Cada usuario en Telegram tenemos un identificador, *ID*. Podemos saber el nuestro iniciando este bot  [[https://t.me/userinfobot][@userinfobot]].

Si queremos añadir el Bot en un Grupo o Canal, para que envíe mensajes o haga cualquier función, tendremos que averiguar el *ID* de ese Grupo o Canal. Para ello reenvía un mensaje desde el Canal/Grupo al Bot  [[https://t.me/ChannelIdBot][@ChannelIdBot]].


** Vamos a crear nuestro Bot
Lo primero que haremos, es confirmar que realmente podemos enviar mensajes con nuestro bot desde la terminal.

Creamos el script:
=nano mi_bot_telegram.sh=

Una vez abierto nano, vamos a copiar el contenido añadiendo el *TOKEN* del bot y nuestro *ID*.
#+BEGIN_SRC 
#!/bin/bash

TOKEN="escribe tu token aquí"
ID="escribe tu id aquí"
MENSAJE="Esto es un Mensaje de Prueba"
URL="https://api.telegram.org/bot$TOKEN/sendMessage"

curl -s -X POST $URL -d chat_id=$ID -d text="$MENSAJE"
#+END_SRC
Ahora daremos permisos de ejecución:

=sudo chmod +x mi_bot_telegram.sh=

Vamos a ejecutarlo:

=sh mi_bot_telegram.sh=

FUNCIONA!!!!!!!!

Si hemos escrito correctamente tanto el *TOKEN* como el número de nuestro *ID*, habremos recibido un mensaje en el chat del bot que hayamos creado con el contenido: *Esto es un Mensaje de Prueba*

Si somos un poco mas atrevidos o conocemos mejor bash, te abras dado cuenta que no era necesario hacer un script y podemos enviar el mensaje desde una única línea de Terminal. Sustituye añade el valor de las variables en la última línea del script así:
#+BEGIN_SRC 
curl -s -X POST https://api.telegram.org/bot"30534591:AAH5d23KtktfTQSWJMT9CiuginbsFQiF_2nB4"/sendMessage -d chat_id="57384545" -d text="Esto es un Mensaje de Prueba"
#+END_SRC
Como puedes ver, he puesto unos valores inventados de muestra.

** Muestra la Ip de la máquina que se conecta por SSH
Si utilizas Bash, sabes que cada vez que te conectas por ssh o inicias una nueva sesión en tu terminal, Bash lee el archivo *.bashrc*. En él, al final de este archivo de configuración, añadiremos la línea de nuestro Bot y dentro del mensaje de texto, en lugar de un mensaje escribiremos:

=$(echo $SSH_CLIENT | awk '{ print $1}')=


Quedaría de la siguiente manera:
#+BEGIN_SRC 
curl -s -X POST https://api.telegram.org/bot"30534591:AAH5d23KtktfTQSWJMT9CiuginbsFQiF_2nB4"/sendMessage -d chat_id="57384545" -d text="Se acaba de contecta por ssh con la IP $(echo $SSH_CLIENT | awk '{ print $1}')"
#+END_SRC
Si quieres probar que realmente funciona desde tu terminal, escribe en ella:

=echo $SSH_CLIENT | awk '{ print $1}'=

** Ip Pública
Vamos a conocer la IP pública y conectarnos directamente con nuestra Raspberry:

=curl ifconfig.co=

Como en el caso anterior, sustituiremos el texto plano por esto:
 
=$(curl ifconfig.co)=

** Temperatura de tu Raspberry
Con este comando, tendré controlada la temperatura de mi raspberry y además, quedará guardado el historial en el chat del Bot:

=/opt/vc/bin/vcgencmd measure_temp=

Sustituye el texto del Bot por:

=$(/opt/vc/bin/vcgencmd measure_temp)=

** Al Iniciar mi servidor
He creado una carpeta llamada "scripts" en el "Home" del usuario. Allí he creado el script del Bot llamado *inicio.sh*, con un mesaje de texto tipo:

*Se ha iniciado mi Raspberry*

Para que esto funciones, vamos a escribir en cron, que cada vez que inicie nuestro servidor, PC, raspberry,... Nos envíe el mensaje:

Escribe en la Terminal:

=crontab -e=

Y en la primera línea, escribiremos lo siguiente:

=@reboot ( sleep 100 ; sh $HOME/scripts/inicio.sh )=

Esto significa que tras 100 segundos después del  inicio de nuestro servidor, pc, raspberry,... ejecutará el script *inicio.sh*, de manera que nos enviará el texto que pusimos en el script "*Se ha iniciado mi Raspberry*".

** Conclusión
Espero que te haya gustado este Post y Podcast. Ahora te toca a ti experimentar y juguetear con tu Bot de Telegram. Comenta tu experiencia en el Grupo de uGeek en Telegram.
* Cursos, Webs, Grupos, Tutoriales... Todo sobre Emacs y OrgMode
:PROPERTIES:
:TITLE:  Actualizado: Cursos, Webs, Grupos, Tutoriales... Todo sobre Emacs y OrgMode
:EXPORT_FILE_NAME: Cursos Webs Grupos Tutoriales Todo sobre Emacs y OrgMode
:DESCRIPTION: Muchos de vosotros me comentáis si os puedo recomendar un sitio donde iniciaros con Emacs y OrgMode
:EXPORT_DATE: 2019-03-15 23:00 2019-03-16
:CATEGORY: emacs
:TAG:      emacs,orgmode,
:END:


#+ATTR_HTML: :width 250px :height 250px
[[./images-blog/emacs.png]]  


Muchos de vosotros me comentáis si os puedo recomendar un sitio donde iniciaros con Emacs y OrgMode. Como una imagen vale mas que mil palabras, la [[https://www.emacswiki.org/emacs?interface=es][EmacsWiki]] me ha llevado al repositorio en GitHub de [[https://github.com/farliz/emacs-academia/blob/master/contenido.md][farliz/emacs-academia]], donde están estos enlaces que te llevan a un magnífico Curso en Vídeo y en Castellano, donde ver un poco como funciona Emacs. 

La verdad es que ahora no tienes escusas para aprender Emacs!!!

En la parte final del curso, adjunta una serie de comandos para descargarlos en Local. Yo los he reagrupado en un script.

He añadido unas conferencias de Medialab-Prado, un vídeo que resume muy bien OrgMode y una lista de vídeos de [[https://www.youtube.com/user/koenighaunstetten][Rainer König]] sobre OrgMode en Inglés pero muy sencillos de seguir.

En la Parte final, añadido una serie de PDF's con comandos y documentación.

Es una información muy interesante, así que agradeciendo el magnífico trabajo de todas las fuentes, he añadido el contenido en la web para no perderlo de vista. 


** Webs, Canales y Grupos de Telegram, Reddit
_Webs_
- [[http://planet.emacs-es.org][Planet Emacses]]
- [[http://planet.emacslife.com/][Planet Emacs Life (Inglés)]]
- [[http://sachachua.com/blog/][Blog de Sachachua (Inglés)]]

_Telegram_
- [[https://t.me/emacs_es][Grupo Emacs]]
- [[https://t.me/Org_Mode][Canal Orgmode]]

_Reddit_
- [[https://www.reddit.com/r/emacs][Emacs]]
- [[https://www.reddit.com/r/planetemacs/][Planet Emacs]]
- [[https://www.reddit.com/r/orgmode/][OrgMode]]

** Vídeos
_Parte 1: Emacs Básico_

 1. [[https://b2aeaa58a57a200320db-8b65b95250e902c437b256b5abf3eac7.ssl.cf5.rackcdn.com/media_entries/8787/emacs1.webm][Introducción]]
 2. [[https://b2aeaa58a57a200320db-8b65b95250e902c437b256b5abf3eac7.ssl.cf5.rackcdn.com/media_entries/8807/emacs2.webm][Buffers 1]]
 3. [[https://b2aeaa58a57a200320db-8b65b95250e902c437b256b5abf3eac7.ssl.cf5.rackcdn.com/media_entries/8808/emacs3.webm][Primeros comandos 1]]
 4. [[https://b2aeaa58a57a200320db-8b65b95250e902c437b256b5abf3eac7.ssl.cf5.rackcdn.com/media_entries/8810/emacs4.webm][Primeros comandos 2]]
 5. [[https://b2aeaa58a57a200320db-8b65b95250e902c437b256b5abf3eac7.ssl.cf5.rackcdn.com/media_entries/8812/emacs5.webm][Modos mayores / Buffers]]
 6. [[https://b2aeaa58a57a200320db-8b65b95250e902c437b256b5abf3eac7.ssl.cf5.rackcdn.com/media_entries/8813/emacs6.webm][Mini buffer / configuración de emacs]]
 7. [[https://b2aeaa58a57a200320db-8b65b95250e902c437b256b5abf3eac7.ssl.cf5.rackcdn.com/media_entries/8814/emacs7.webm][init.el / configuración de Emacs]]
 8. [[https://b2aeaa58a57a200320db-8b65b95250e902c437b256b5abf3eac7.ssl.cf5.rackcdn.com/media_entries/8815/emacs8.webm][Mas configuración]]
 9. [[https://b2aeaa58a57a200320db-8b65b95250e902c437b256b5abf3eac7.ssl.cf5.rackcdn.com/media_entries/8816/emacs9.webm][Linea de modo]]

  * [[https://www.dropbox.com/s/xmflteig5j77hf4/suelo.txt?dl=0][suelo.txt]]

10. [[https://b2aeaa58a57a200320db-8b65b95250e902c437b256b5abf3eac7.ssl.cf5.rackcdn.com/media_entries/8817/emacs10.webm][Buscar palabras en un texto]]
11. [[https://b2aeaa58a57a200320db-8b65b95250e902c437b256b5abf3eac7.ssl.cf5.rackcdn.com/media_entries/8818/emacs11.webm][Buscar y reemplazar]]
12. [[https://b2aeaa58a57a200320db-8b65b95250e902c437b256b5abf3eac7.ssl.cf5.rackcdn.com/media_entries/8819/emacs12.webm][Importante]]
13. [[https://b2aeaa58a57a200320db-8b65b95250e902c437b256b5abf3eac7.ssl.cf5.rackcdn.com/media_entries/8820/emacs13.webm][ido-mode]]
14. [[https://b2aeaa58a57a200320db-8b65b95250e902c437b256b5abf3eac7.ssl.cf5.rackcdn.com/media_entries/8821/emacs14.webm][customize]]
15. [[https://b2aeaa58a57a200320db-8b65b95250e902c437b256b5abf3eac7.ssl.cf5.rackcdn.com/media_entries/8822/emacs15.webm][instalar paquetes (plugins)]]
16. [[https://b2aeaa58a57a200320db-8b65b95250e902c437b256b5abf3eac7.ssl.cf5.rackcdn.com/media_entries/8823/emacs16.webm][COPIAR / CORTAR / PEGAR / DESHACER]]
17. [[https://b2aeaa58a57a200320db-8b65b95250e902c437b256b5abf3eac7.ssl.cf5.rackcdn.com/media_entries/8824/emacs17.webm][helm-mode]]
18. [[https://b2aeaa58a57a200320db-8b65b95250e902c437b256b5abf3eac7.ssl.cf5.rackcdn.com/media_entries/8825/emacs18.webm][MOVIMIENTOS ESENCIALES]]
19. [[https://b2aeaa58a57a200320db-8b65b95250e902c437b256b5abf3eac7.ssl.cf5.rackcdn.com/media_entries/8826/emacs19.webm][COPIAR y PEGAR II]]
20. [[https://b2aeaa58a57a200320db-8b65b95250e902c437b256b5abf3eac7.ssl.cf5.rackcdn.com/media_entries/8827/emacs20.webm][Modos menores / auto-fill-mode]]
21. [[https://b2aeaa58a57a200320db-8b65b95250e902c437b256b5abf3eac7.ssl.cf5.rackcdn.com/media_entries/8828/emacs21.webm][solarized-theme / Opcional]]

Al finalizar esta sección, estarán en capacidad de seguir y entender la siguiente guía. [[http://therandymon.com/papers/emacs-for-writers.pdf][Emacs for writers]]

_Parte 2_

 1. [[https://b2aeaa58a57a200320db-8b65b95250e902c437b256b5abf3eac7.ssl.cf5.rackcdn.com/media_entries/8829/emacs22.webm][Corrección ortográfica 1]]
 2. [[https://b2aeaa58a57a200320db-8b65b95250e902c437b256b5abf3eac7.ssl.cf5.rackcdn.com/media_entries/8830/emacs23.webm][Corrección ortográfica 2]]
 3. [[https://b2aeaa58a57a200320db-8b65b95250e902c437b256b5abf3eac7.ssl.cf5.rackcdn.com/media_entries/8831/emacs24.webm][BibTeX]]
 4. [[https://b2aeaa58a57a200320db-8b65b95250e902c437b256b5abf3eac7.ssl.cf5.rackcdn.com/media_entries/8833/emacs25.webm][AucTeX y RefTeX instalación]]
 5. [[https://b2aeaa58a57a200320db-8b65b95250e902c437b256b5abf3eac7.ssl.cf5.rackcdn.com/media_entries/8834/zotero.webm][Zotero]]
 6. [[https://b2aeaa58a57a200320db-8b65b95250e902c437b256b5abf3eac7.ssl.cf5.rackcdn.com/media_entries/8836/emacs26.webm][LaTeX demo]]
      + [[https://www.dropbox.com/s/0ibsirx4a65eq17/tutorial.zip?dl=0][Archivo]]
 7. [[https://b2aeaa58a57a200320db-8b65b95250e902c437b256b5abf3eac7.ssl.cf5.rackcdn.com/media_entries/8841/emacs26.webm][Movimientos esenciales II]]
 8. [[https://b2aeaa58a57a200320db-8b65b95250e902c437b256b5abf3eac7.ssl.cf5.rackcdn.com/media_entries/8842/emacs27.webm][Evaluar código LISP C-x C-e]]
 9. [[https://b2aeaa58a57a200320db-8b65b95250e902c437b256b5abf3eac7.ssl.cf5.rackcdn.com/media_entries/8885/emacs28.webm][Configuración Final]]
10. [[https://b2aeaa58a57a200320db-8b65b95250e902c437b256b5abf3eac7.ssl.cf5.rackcdn.com/media_entries/8911/emacs29.webm][Edición del texto]]
11. [[https://b2aeaa58a57a200320db-8b65b95250e902c437b256b5abf3eac7.ssl.cf5.rackcdn.com/media_entries/8915/emacs30.webm][Edición de texto II]]
12. [[https://b2aeaa58a57a200320db-8b65b95250e902c437b256b5abf3eac7.ssl.cf5.rackcdn.com/media_entries/8916/emacs31.webm][Formato I]]

  * Corrección: En este video cuando digo C-h, quiero decir M-h

13. [[https://b2aeaa58a57a200320db-8b65b95250e902c437b256b5abf3eac7.ssl.cf5.rackcdn.com/media_entries/8917/emacs32.webm][Markdown]]
14. [[https://b2aeaa58a57a200320db-8b65b95250e902c437b256b5abf3eac7.ssl.cf5.rackcdn.com/media_entries/8919/emacs33.webm][ConTeX]]

  * [[https://cloud.openmailbox.org/index.php/s/iFRESi5QDkT6SXJ][PDF]]

15. [[https://b2aeaa58a57a200320db-8b65b95250e902c437b256b5abf3eac7.ssl.cf5.rackcdn.com/media_entries/13066/helm-bibtex.medium.webm][Helm-bibtex]]
16. [[https://b2aeaa58a57a200320db-8b65b95250e902c437b256b5abf3eac7.ssl.cf5.rackcdn.com/media_entries/11660/emacs-pdf.medium.webm][export-to-pdf]]

_Curso Básico de ConTeXt_

1.[[https://b2aeaa58a57a200320db-8b65b95250e902c437b256b5abf3eac7.ssl.cf5.rackcdn.com/media_entries/13173/context_1.webm][Instalación]]

2.[[https://b2aeaa58a57a200320db-8b65b95250e902c437b256b5abf3eac7.ssl.cf5.rackcdn.com/media_entries/13174/context-presentacion.webm][Presentación]]

3.[[https://b2aeaa58a57a200320db-8b65b95250e902c437b256b5abf3eac7.ssl.cf5.rackcdn.com/media_entries/13175/context-extra1.webm][simpleslides]]

4.[[https://b2aeaa58a57a200320db-8b65b95250e902c437b256b5abf3eac7.ssl.cf5.rackcdn.com/media_entries/13176/context-ayuda.webm][Manual de ConTeXt]]

_Descargar todos los Vídeos_

Para descargar todos los videos pueden ejecutar las siguientes lineas en una terminal.

 0. mkdir emacs-videos && cd emacs-videos
   
 1. wget [[https://github.com/farliz/emacs-academia/blob/master/contenido.md][https://github.com/farliz/emacs-academia/blob/master/contenido.md]]
   
 2. grep -Eo '(http|https)://.+webm' contenido.md > videos.txt
   
 3. wget -i videos.txt
   
 Canal en Goblinrefuge

[[https://goblinrefuge.com/mediagoblin/u/farliz/][https://goblinrefuge.com]]

_Script para descargar los Vídeos_

#+BEGIN_SRC 
#/bin/bash/
mkdir emacs-videos && cd emacs-videos
wget https://github.com/farliz/emacs-academia/blob/master/contenido.md
grep -Eo '(http|https)://.+webm' contenido.md > videos.txt
wget -i videos.txt   
#+END_SRC
** Vídeos, listas y conferencia sobre Orgmode


#+ATTR_HTML: :width 250px :height 250px
[[./images-blog/orgmode.png]]  


_Mi primera configuración Emacs con elisp y orgmode_

#+HTML:<iframe width="560" height="315" src="https://www.youtube.com/embed/bnu-ZGpRly4" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

_"Organiza tu vida" Emacs y Org-mode Madrid 2017 Medialab-Prado_

#+HTML:<iframe width="560" height="315" src="https://www.youtube.com/embed/QBPTNz3Qqqo" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

_"Organiza tu vida" Emacs y Org-mode Madrid 2017 Medialab-Prado_

#+HTML:<iframe width="560" height="315" src="https://www.youtube.com/embed/bzZ09dAbLEE" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

_OrgMode tutorial_

#+HTML:<iframe width="560" height="315" src="https://www.youtube.com/embed/sQS06Qjnkcc" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>


** Manuales
- [[http://www.davidam.com/docu/orgguide.es.html][Guía sobre OrgMode]]
- [[https://orgmode.org/worg/orgguide/orgguide.es.pdf][Manual en PDF de OrgMode]]
- [[https://orgmode.org/orgguide.pdf][Manual en Inglés. Última versión OrgMode]]
- [[http://es.tldp.org/Tutoriales/doc-tutorial-emacs/intro_emacs.pdf][Manual sobre Emacs]]
- [[http://portal.uned.es/pls/portal/docs/PAGE/UNED_MAIN/LAUNIVERSIDAD/UBICACIONES/01/OFERTAESTUDIOS/GRADOS_CIENCIAS/SOFTWARE%20DESCARGAS%20LINUX/MANUALES/EMACS_MANUAL_MINIMO_17PAGS.PDF][Manual mínimo Emacs]]
- [[http://www.hectormora.info/emacs_man.pdf][Breve Introducción de Emacs]]
- [[http://di002.edv.uniovi.es/~labra/cursos/latex04/cursoLaTeX.pdf][Presentación Emacs y Latex]]
- [[https://blyx.com/public/docs/programacion/Emacs.pdf][Plantilla Emacs]]




* Monta un servidor web Nginx, con una sola línea de Terminal (Docker)
:PROPERTIES: 
:TITLE:  Monta un servidor web Nginx, con una sola línea de Terminal (Docker)
:EXPORT_FILE_NAME: Monta un servidor web Nginx con una sola linea de Terminal Docker
:DESCRIPTION: Si quieres montar un servidor web en un pispás y no complicarte la vida, el Docker oficial de nginx es una buenísima solución
:EXPORT_DATE: 2019-03-25 21:10 
:CATEGORY: docker
:TAG:      servidor,web
:END:

Si quieres montar un servidor web en un pispás y no complicarte la vida, el [[https://hub.docker.com/_/nginx][Docker oficial de Nginx]] es una buenísima solución.
Hay tres motivos por los cuales instalar este Docker: 
- Versión oficial a la última
- Solo una línea de Terminal
- Funciona con todas las arquitecturas (amd64, arm32v6, arm32v7, arm64v8, i386, ppc64le, s390x)


[[./images-blog/nginx.png]]

También podemos instalar Nginx, partiendo de Alpine Linux, ocupando aproximadamente una décima parte.
En próximos Post y Podcast, os hablaré más de Alpine Linux que para Docker que es espectacular. Nos permite montar montones de servicios con un mínimo espacio.


Para utilizar otro puerto que no sea el 80, por ejemplo el puerto 90, ejecutaremos en la línea de terminal =-p 90:80=.

** Montando el Docker oficial de Nginx para arquitectura 64bits
Este Docker funciona con todas las arquitecturas especificando o no el TAG de la misma. El tamaño de la Imagen es de 109MB.
Vamos a instalarlo y probar: La carpeta *$HOME/docker/nginx*, será la raiz del servidor web.

=docker run --name nginx -d -p 80:80 -v $HOME/docker/nginx:/usr/share/nginx/html:ro nginx=


** Docker oficial de Nginx, arquitectura 64bits. Alpine Linux
Ahora vamos a Instalar el mismo Docker oficial, pero partiendo de un Alpine Linux. Tan solo 16.1MB de Imagen!!!
La carpeta *$HOME/docker/nginx*, será la raiz del servidor web.

=docker run --name nginx -d -p 80:80 -v $HOME/docker/nginx:/usr/share/nginx/html:ro amd64/nginx:alpine=


** Docker oficial de Nginx en Raspberry
Me he emocionado tanto instalando Nginx desde un Alpine Linux, que ahora quiero hacer lo propio en mi Raspberry. Tamaño de la Imagen de 13,4 Mb en mi Raspberry.

Como veis, he utilizado el mismo comando que el apartado anterior. La carpeta *$HOME/docker/nginx*, será la raiz del servidor web.

=docker run --name nginx -d -p 80:80 -v $HOME/docker/nginx:/usr/share/nginx/html:ro nginx:alpine=
** Conclusión
Estoy comenzando a tener Dockerdependencia y es que es inevitable. Poder montar tantos servidores web como quiera con un puerto diferente y con la última versión... Como dice el anuncio, no tiene precio, jejeje
* Enviando Imágenes, audios, archivos... con mi bot de Telegram de una sola Línea de terminal
:PROPERTIES: 
:TITLE:  Enviando Imágenes, audios, archivos... con mi bot de Telegram de una sola Línea de Terminal
:EXPORT_FILE_NAME: Enviando Imagenes audios archivos con mi bot de Telegram de una sola Linea de terminal
:DESCRIPTION: En el Post anterior vimos como enviar archivos de texto plano a través del Bot, estoy seguro que estas totalmente emocionado y ahora te preguntas si también podemos enviar imágenes, archivos,... La respuesta es Sí!
:EXPORT_DATE: 2019-03-28 16:25
:CATEGORY: telegram
:TAG:      bot,
:END:
El duelo está a un nivel muy alto y sabia que enfrentarme a Lorenzo, no iba a ser tarea fácil. La pasión que ambos tenemos por la creación de Bots en  Telegram, va ha hacer que este duelo nos haga asentar muchísimo mas nuestros conocimientos.


[[./images-blog/botfather.png]]

En el Post anterior vimos como enviar archivos de texto plano a través del Bot, estoy seguro que estas totalmente emocionado y ahora te preguntas si también podemos enviar imágenes, archivos,... La respuesta es Sí!!, así que vamos a ver como enviar estos desde una sola línea de terminal con bash, pero antes, vamos a hacer recuento de como van los Post del duelo: 

** Recuento de las últimas publicaciones sobre bots de Telegram (el duelo)
Estos son los Post de [[https://www.atareao.es/][atareao.es]] y míos sobre los bots de Telegram:
- [[https://www.atareao.es/tutorial/crea-tu-propio-bot-para-telegram/un-bot-de-telegram-con-php/][Un bot de Telegram con PHP]]
- [[https://www.atareao.es/tutorial/crea-tu-propio-bot-para-telegram/bot-en-python-para-telegram/][Un bot en Python para Telegram (y en una sola línea)]]
- [[https://ugeek.github.io/blog/post/2019-03-14-crea-un-bot-de-telegram-con-bash-y-una-sola-linea-de-terminal.html][Crea un Bot de Telegram con Bash y una sola línea de Terminal]]

Ahora que ya estamos al día, vamos al tema:  
** Enviar Mensajes de Texto (Repaso)
Nos quedamos aquí, en enviar mensajes de texto plano. Si no sabes como crear tu bot o has llegado aquí y no sabes como empezar, te remito al anterior Post [[https://ugeek.github.io/blog/post/2019-03-14-crea-un-bot-de-telegram-con-bash-y-una-sola-linea-de-terminal.html][Crea un Bot de Telegram con Bash y una sola línea de Terminal]], antes que nos adentramos mas a fondo.

Enviaremos nuestro mensaje de texto plano sustituyendo en esta línea, estos parámetros por nuestros valores:
- TOKEN
- ID
- TU MENSAJE DE TEXTO
#+BEGIN_SRC 
curl -s -X POST https://api.telegram.org/bot"<TOKEN>"/sendMessage -d chat_id="<ID>" -d text="<TU MENSAJE DE TEXTO>"
#+END_SRC
** Enviar una imagen
Para enviar imágenes con nuestro Bot, tendremos que especificar la ruta completa del archivo así como el Token e ID:
- TOKEN
- ID
- RUTA DE NUESTRA IMÁGEN ( Tipo: "~/Imágenes/mifoto.jpg")

 #+BEGIN_SRC 
curl -X  POST "https://api.telegram.org/bot"<TOKEN>"/sendPhoto" -F chat_id="<ID>" -F photo="@<RUTA DE NUESTRA IMAGEN>"
#+END_SRC
** Enviar una imagen que esté en Internet

También podemos enviar imágenes que esten en internet. Del mismo modo, tenemos que especificar la ruta donde esté esta. Atención que cambia un poco la línea, ya no tiene el *@* ante la ruta:
- TOKEN
- ID
- RUTA DE NUESTRA IMÁGEN ( Tipo: "=https://ugeek.github.io/blog/icon/ugeek.png=")
#+BEGIN_SRC 
curl -X  POST "https://api.telegram.org/bot"<TOKEN>"/sendPhoto" -F chat_id="<ID>" -F photo="<RUTA DE LA IMAGEN EN INTERNET>"
#+END_SRC
** Adjuntar texto junto a la Imágen
Habrás visto que hay imágenes que llevan adjunto un texto en la parte inferior. Para hacer esto, tendremos que adjuntar un nuevo tag a nuestra línea:
- TOKEN
- ID
- RUTA DE NUESTRA IMÁGEN
- TEXTO JUNTO IMAGEN

 #+BEGIN_SRC 
curl -X  POST "https://api.telegram.org/bot"<TOKEN>"/sendPhoto" -F chat_id="<ID>" -F caption="<TEXTO JUNTO IMAGEN>" -F photo="@<RUTA DE NUESTRA IMAGEN>"
#+END_SRC
** Enviar archivos
Para enviar archivos, la línea es muy similar a la de enviar imágenes, solo que en este caso utilizaremos */sendDocument*. También como con las imágenes, especificaremos la ruta completa:
- TOKEN
- ID
- RUTA DEL ARCHIVO
 #+BEGIN_SRC 
curl -X  POST "https://api.telegram.org/bot"<TOKEN>"/sendDocument" -F chat_id="<ID>" -F document="@<RUTA DEL ARCHIVO>"
#+END_SRC

** Adjuntar texto junto al archivo
Para adjunta texto junto a la archivo:

- TOKEN
- ID
- RUTA DEL ARCHIVO
- TEXTO JUNTO IMAGEN
 #+BEGIN_SRC 
curl -X  POST "https://api.telegram.org/bot"<TOKEN>"/sendDocument" -F chat_id="<ID>" -F caption="<TEXTO JUNTO IMAGEN> -F document="@<RUTA DEL ARCHIVO>"
#+END_SRC
** Conclusión
Con todo esto y un poco de imaginación, ahora podemos ampliar mucho más las posibilidades de automatización. Espero que os haya gustado el Post y a disfrutar con los Bots
 




* Veracrypt en Ubuntu y tu Raspberry por Terminal
:PROPERTIES: 
:TITLE:  Veracrypt en Ubuntu y tu Raspberry por Terminal
:EXPORT_FILE_NAME: Veracrypt en Ubuntu y tu Raspberry por Terminal
:DESCRIPTION: Es muy probable que desees tener parte de tus datos cifrados para poder almacenarlo en una nube pública o simplemente quieras cifrar parte del contenido almacenado en tu Raspberry
:EXPORT_DATE: 2019-03-29 21:00
:CATEGORY: cifrado
:TAG:      servidor,raspberry
:END:



[[./images-blog/veracrypt.png]]

Es muy probable que desees tener parte de tus datos cifrados para poder almacenarlo en una nube pública o simplemente quieras cifrar el contenido almacenado en tu Raspberry.
 
Quizás quieras cifrar un número de archivos que hay en un PC compartido con otras personas y este contenido lo tengas sincronizado con Syncthing hacia tu Raspberry. 

En tu Raspberry, montarás el Volumen descifrado en otra carpeta, que estará sincronizada también con Syncthing a tu movil, pudiendo ver o editar los archivos en todo momento.

Hay varios métodos como hacerlo que os explicaré en siguientes artículos y Podcast, pero hoy voy a explicaros como hacerlo mediante Veracrypt, una derivación de Truecrypt, que supuestamente Veracrypt a solucionado los problemas encontrados en la auditoria de seguridad.

Veracrypt es una herramienta que permitirá crear un único archivo cifrado de un tamaño que determinaremos en el momento de la creación, y dentro de él estarán todos los archivos que deseemos guardar. Para poder editar, leer,... estos archivos, montaremos el archivo cifrado con Veracrypt en una carpeta vacía, como si se tratase de un usb o disco duro.

Es totalmente multiplataforma y podemos utilizar interfaz gráfica desde el escritorio. 

En este Post os voy a explicar como hacerlo desde la terminal, pero si os resulta muy complicado crear el contenedor cifrado desde la terminal, hacerlo desde un PC y sincronizarlo con vuestra Raspberry.

** Instalación en Ubuntu
En Ubuntu lo instalaríamos mediante PPA:
#+BEGIN_SRC 
sudo add-apt-repository ppa:unit193/encryption
sudo apt-get update
sudo apt install veracrypt
#+END_SRC
- [[https://launchpad.net/~unit193/+archive/ubuntu/encryption][Fuente]]
** Instalación en Raspberry

Instalamos las siguientes dependencias:

#+BEGIN_SRC 
sudo apt-get update
sudo apt-get install libfuse-dev makeself libwxbase3.0-0v5
#+END_SRC

Instalamos la última versión de Veracrypt que podemos [[https://archive.codeplex.com/?p=veracrypt][encontrar en este enlace:]]

#+BEGIN_SRC 
cd 
mkdir veracryptfiles
cd veracryptfiles
wget -L -O veracrypt-1.21-raspbian-setup.tar.bz2 https://launchpad.net/veracrypt/trunk/1.21/+download/veracrypt-1.21-raspbian-setup.tar.bz2
#+END_SRC

Extraemos el archivo descargados:

#+BEGIN_SRC 
tar -vxjf ./veracrypt-1.21-raspbian-setup.tar.bz2
chmod +x veracrypt-1.21-setup-*
#+END_SRC

Instalamos ejecutando el script:

#+BEGIN_SRC 
./veracrypt-1.21-setup-console-armv7
#+END_SRC

Ahora seguiremos los pasos que nos pedirá el programa:
- =1= (instalar)
- =Enter= (aceptar la licencia)
- =yes=

** Desinstalar
Para desinstalar:
#+BEGIN_SRC 
rm -r veracryptfiles
#+END_SRC
** Crear un Volumen

Primero crearemos una carpeta donde queremos montar el volumen. Por ejemplo:

#+BEGIN_SRC 
mkdir -p /media/veracrypt
#+END_SRC

Vamos a crear nuestro volumen, para ello teclearemos este comando y Veracrypt nos hará una serie de preguntas que os explico a continuación. Recuerda, como te he comentado, que si te resulta complejo este paso, crealo desde tu PC y sincronízalo con tu Raspberry.
#+BEGIN_SRC 
veracrypt -t -c
#+END_SRC
Ahora veracrypt nos preguntará:
- Si queremos que el volumen sea oculto. En caso de no serlo, pulsa =1=
- Introduce la ruta completa del archivo cifrado: =$HOME/archivo_cifrado=
- Ahora nos preguntará el tamaño del archivo: =(sizeK/size[M]/sizeG)= por ejemplo 50M (50Mb)
- Nos pedirá con que algoritmo queremos cifrar nuestro archivo, el mas popular es AES, si quieres complicar un poco mas la cosa, selecciona uno de los otros. Introduce el número deseado
- Selecciona el algoritmo de hash deseado =1=
- Ahora seleccionaremos el sistema de archivos. =5=
- Introduce la contraseña. Se recomienda mas de 20 caracteres
- PIM significa Multiplicador de Iteraciones Personales. Presiona =ENTER=
- Si desea utilizar el archivo de claves en lugar de la contraseña, aquí puede definir el archivo de claves. Yo no lo utilizaré, así que presiono =ENTER=
- Como en la versión de terminal, no podemos utilizar el ratón como en la versión gráfica, vamos a teclear 320 caracteres aleatorios para crear la base para tu clave de cifrado.
- Ahora paciencia, la Raspberry será un poco lenta si el volumen que deseamos crear es muy grande

** Montar Volumen

Para montar un volumen ya creado, como la mayoría de cifrados en GNU/Linux, el comando sería:


=veracrypt <carpeta_origen> <carpeta_montaje>=

Ahora vamos a seguir el ejemplo práctico:
#+BEGIN_SRC 
veracrypt $HOME/archivo_cifrado /media/veracrypt
#+END_SRC

Ahora te preguntará que ingreses el PIM, el archivo de claves y si has creado un volumen normal, no oculto. 
Ni no has ingresado nada de esto, pulsa a todo *ENTER*, *ENTER*, *ENTER*. 


Ya tendrás el volumen montado en la ruta que has especificado. Si quieres que la próxima vez no te pregunte nada al montar:

#+BEGIN_SRC 
veracrypt $HOME/archivo_cifrado /media/veracrypt --pim=0 --keyfiles= --protect-hidden=no
#+END_SRC

** Desmontar la unidad

Para desmontar todas las unidades montadas con veracrypt:

=veracrypt -d=

=veracrypt -d <carpeta_origen>=
** Alias puede ser una Buena Idea
Alias puede ser una buena idea si no queremos recordar la ruta de las carpetas:

Enviar mediante printf a .bashrc nuestro comando con las carpetas que vamos a utilizar y el alias, en mi caso, *veracrypt_m*.
#+BEGIN_SRC 
printf "\nalias veracrypt_m=\"veracrypt $HOME/veracrypt /media/veracrypt --pim=0 --keyfiles= --protect-hidden=no\"" >> .bashrc 
#+END_SRC



Para desmontar, utilizaremos el alias *veracrypt_d*.
#+BEGIN_SRC 
printf "\nalias veracrypt_d=\"veracrypt -d $HOME/veracrypt"" >> .bashrc 
#+END_SRC


** Conclusión 
El punto positivo de Veracrypt, es que al ser un único archivo no hay graves problemas de sincronización, el punto negativo, es que si el archivo es muy grande, no es muy aconsejable hacer sincronizaciones cifradas con nuestro movil, ya que podriamos consumir nuestra tarifa de datos.
** Fuentes
- https://www.veracrypt.fr/en/Downloads.html
- https://www.veracrypt.fr/en/Command%20Line%20Usage.html
- https://jacekstyrylski.github.io/2017/04/02/Vera-Crypt-OSMC/
* Crear página de error 404 en GitHub Pages
:PROPERTIES: 
:TITLE:  Crear página de error 404 en GitHub Pages
:EXPORT_FILE_NAME: Crear pagina de error 404 en GitHub Pages
:DESCRIPTION: Después de cambiar la página de uGeek de Jekyll a Org-Bash-Blog, muchos de los artículos antiguos han cambiado ruta de la dirección web en el servidor y si llegas a ellas, quedas en una página de error de GitHub que no tiene relación con la web. Decidí crear una página personalizada de error 404
:EXPORT_DATE: 2019-03-29 22:30
:CATEGORY: web
:TAG:      git,github
:END:

#+HTML_HEAD:<meta name="twitter:title" content="Crear página de error 404 en GitHub Pages" />     
#+HTML_HEAD:<meta name="twitter:description" content="Después de cambiar la página de uGeek de Jekyll a Org-Bash-Blog, muchos de los artículos antiguos han cambiado ruta de la dirección web en el servidor y si llegas a ellas, quedas en una página de error de GitHub que no tiene relación con la web. Decidí crear una página personalizada de error 404" />     
#+HTML_HEAD:<link rel="shortlink' href='https://ugeek.github.io/https://ugeek.github.io/blog/post/2019-03-29-crear-pagina-de-error-404-en-github-pages.html" /> 

[[./images-blog/404.png]]

Después de cambiar la página de uGeek de Jekyll a Org-Bash-Blog, muchos de los artículos antiguos han cambiado la ruta de dirección web en el servidor y si llegas a ellas, quedas en una página de error de GitHub que no tiene relación con la web. Decidí crear una página personalizada de error 404 y que tras 3 segundos,tal como expliqué [[https://ugeek.github.io/blog/post/2018-12-29-redirigir-el-trafico-de-pagina-web-a-otra.html][en este Post]], redireccionará con el Index del blog. Pero... 

¿Como se hace una página de error 404 en GitHub Pages?

Súper Fácil!!!!

Tan simple como crear una página *.html* en la raiz del repositorio y nombrarla como *404.html*. Cada vez que alguien acceda a una página que esa no exista, GitHub Pages redirigirá el tráfico hacia esta página *404.html*.

 
* TODO Notificaciones Org Mode en Telegram con mi Bot 
:PROPERTIES:
:TITLE: Notificaciones Org Mode en Telegram con mi Bot
:EXPORT_FILE_NAME: Notificaciones Org Mode en Telegram con mi Bot
:DESCRIPTION: En artículos anteriores, así como en el Podcast, os he explicado como enviar notificaciones de texto, imágenes y archivos, a través de un Bot en Telegram que podemos crear
:EXPORT_DATE: 2019-03-31 10:30
:CATEGORY: emacs
:TAG: orgmode,telegram,raspberry
:END:

[[./images-blog/telegram2org.png]]


En artículos anteriores, así como en el Podcast, os he explicado [[https://ugeek.github.io/blog/post/2019-03-28-enviando-imagenes-audios-archivos-con-mi-bot-de-telegram-de-una-sola-linea-de-terminal.html][como enviar notificaciones de texto, imágenes y archivos]], a través de un Bot en Telegram que podemos crear.

Si utilizas orgmode, todo.txt o cualquier otro archivo de texto plano para gestionar tus tareas, imagino que el poder enviar mensajes de texto para recibirlos en tu movil o PC y tener un sistema basado en Unix como Linux, te habrá abierto un mundo de posibilidades.

En el artículo, de hoy voy a explicaros un ejemplo de como recibir todas las tareas pendientes que tengo en mi archivo orgmode, que están en estado TODO. Recordar que yo he utilizado este ejemplo, pero vosotros podéis hacer lo propio con los estados *WAIT*, *DONE*,... así como las prioridades *#A*, *#B*, etc... Simplemente tenéis que adaptar la línea de terminal a vuestra necesidad.

Voy a explicarlo y veréis que es súper sencillo.

** Filtrar los estados *TODO*

Para mostrar todas las líneas que tengan estado TODO, vamos a utilizar el comando *grep*. Yo en mi caso, una vez se visualice las líneas en Telegram, no quiero que aparezca ni el asterisco, ni la palabra *TODO*, así que utilizaré el comando *sed* para sustituir el texto: =* TODO=, por =-=

=grep TODO agenda.org | sed -e 's/* TODO/-/g'=

Como es posible que no me fije en la fecha del chat, para comprobar a que día pertenece la notificación, voy a añadir la fecha del día de hoy en la notificación:
 
=date +'%A %d de %B del %Y' -> será del tipo: domingo 31 de marzo del 2019=

** Enviando la notificación
Ya lo tenemos todo. Así que vamos con la línea de terminal. Recordar que tenemos que añadir a esta línea el <TOKEN> y nuestro <ID>:

#+BEGIN_SRC 
curl -X "POST" "https://api.telegram.org/bot<TOKEN>/sendMessage" -d chat_id=<ID> -d text="$(echo -e "Tareas Pendientes: $(date +'%A %d de %B del %Y')\n" ; grep TODO agenda.org | sed -e 's/* TODO/-/g') "
#+END_SRC

Esta línea podemos programarla mediante *cron* a un día y hora determinada.

** Conclusión

Este es un pequeño ejemplo de todas las posibilidades que tenemos combinando la terminal, con servicios como Telegram que nos permite utilizar su api para recibir notificaciones. 

También demostrar que el utilizar orgmode, no solo no es una limitación, sino que nos permite personalizar y ampliar muchísimo mas las posibilidades de gestión de nuestras tareas y notas.

* TODO Tomb. Mis secretos son una Tumba. Crifrar Archivos 
:PROPERTIES:
:TITLE: Tomb. Mis secretos son una Tumba. Crifrar Archivos
:EXPORT_FILE_NAME: Tomb Mis secretos son una Tumba Crifrar Archivos
:DESCRIPTION: Hoy toca el turno de Tomb. Un script para cifrar archivos muy pero que muy interesante
:EXPORT_DATE: 2019-03-31 23:00
:CATEGORY: cifrado
:TAG: raspberry,servidor,cifrado
:END:

Seguimos con la serie de aplicaciones para cifrar nuestros archivos. Hoy toca el turno de Tomb. Un script para cifrar archivos muy pero que muy interesante.

[[./images-blog/tomb.png]]

Tomb es aplicación basada en un script de software libre que nos permite crear un archivo cifrado en forma de contenedor, que llamaremos tomb "tumba" y que posteriormente podremos montar como si fuera un USB o HDD. Es una aplicación muy parecida a [[https://ugeek.github.io/blog/post/2019-03-29-veracrypt-en-ubuntu-y-tu-raspberry-por-terminal.html][Veracrypt, que hablé en el Post anterior]]. Su código está disponible en [[https://github.com/dyne/Tomb][este repositorio de GitHub]], así que si tenemos conocimientos, podemos ver como está hecho y eso da una muy buena confiabilidad.

Después de crear la tumba (contenedor), crearemos la llave para abrir esta. Deberemos guardar muy bien esta llave, ya que si la perdemos, perderemos nuestros archivos para siempre. En la parte final del Post, explico como convertir la llave en una imagen, por ejemplo, para despistar a posibles intrusos. 

*Recordar que no es nada aconsejable dejar la llave junto a la tumba.*

** Instalación en Ubuntu 18.04
En Ubuntu lo tenemos muy facil, tan simple como instalar desde los repositorios:

=sudo apt install tomb=

** Instalando en Raspberry con Raspbian

Comenzamos instalando:

=sudo apt-get install gettext zsh cryptsetup pinentry-curses=

Descargamos la última versión desde [[https://files.dyne.org/tomb/][aquí]]:

=wget https://files.dyne.org/tomb/Tomb-2.5.tar.gz=

Descomprimimos:

=tar xzvf Tomb-2.5.tar.gz=

Accedemos a la carpeta y compilamos:

#+BEGIN_SRC 
cd Tomb-2.5/
sudo make install
#+END_SRC
Después instalamos:
#+BEGIN_SRC 
sudo install -Dm755 tomb /usr/local/bin/tomb
sudo install -Dm644 doc/tomb.1 /usr/local/share/man/man1/tomb.1
#+END_SRC
Ya está instalado!!! Parecía mas complicado...

** Creando la Tumba
Vamos a crear nuestra primera tumba, dentro de esta, añadiremos los archivos que queremos que queden cifrados. Si nuestra máquina tiene activa la swap, deberemos utilizar el tag *-f* al final del comando, para que no deje rastro alguno de los archivos que contiene nuestra tumba.

Creamos la Tumba con 100Mb de Tamaño:

=tomb dig -s 100 documentos.tomb -f= 


Ahora crearemos la llave e introduciremos la contraseña. Paciencia porque este proceso, puede tardar en función del tamaño, unos minutos. También nos pedirá la contraseña del usuario con permisos sudo.

=tomb forge -k documentos.tomb.key -f=  


Ya se habrá creado tanto la tumba como la llave. La llave llevará el nombre de la tumba, pero si queremos podemos renombrarla.

Cerraremos el contenedor con la llave creada.

=tomb lock -k documentos.tomb.key documentos.tomb=

** Abrir la tumba
Para abrir la tumba y comenzar a guardar archivos dentro de ella, necesitaremos la llave. Yo estoy utilizando el mismo directorio, pero si está en otro, especificar la ruta completa de donde esté:

=tomb open -k documentos.tomb.key documentos.tomb -f=

Normalmente, el volumen se montará en =/media/documentos/=.

** Cerrar tumba
Para cerrar la tumba, súper sencillo. Utilizaremos *close*:

=tomb close=

Cerrar todas las tumbas y aplicaciones que se están haciendo uso de los archivos que están en las tumbas:

=tomb slam all=

** Ocultando tu llave en una foto 

Primero tenemos que instalar steghide

=sudo apt install steghide=

Eligimos una imagen para guardar dentro la llave, en mi caso se llamará *imagen.jpg*. Nos pedirá una contraseña

=tomb bury -k documentos.tomb.key imagen.jpg=

Ya podemos eliminar nuestra llave, porque esta, está en el interior de la imagen oculta.

Para poder volver a extraer la llave de la imagen:

=tomb exhume -k nombredellave imagen.jpg= 


Para abrir nuestra tumba con la imágen:

=tomb open -k imagen.jpg documentos.tomb=

** Listar tumbas abiertas
Vamos a listar todas las tumbas abiertas e información sobre el tamaño, espacio libre,...

=tomb list=

** Ampliar mas tamaño
Una de las cosas que más me ha gustado, es que una vez creada la tumba, no estamos limitados para siempre a ese tamaño, sino que podemos modificarlo pero solo para ampliarlo. Voy a ampliar de 100Mb iniciales a 350Mb:

=tomb resize -s 310 -k imagen.jpg documentos.tomb -f=

En el momento de la ampliación, nos pedirá la llave y contraseña.

** Mas Ayuda

Sintaxis:

 =tomb [opciones]  [argumentos]=

Podemos ver todas las opciones con el comando de ayuda o accediendo al manual:

=tomb -h=


=man tomb=

** Conclusión 
Voy a darle la oportunidad a este método de cifrar los archivos durante un tiempo, porque me parece muy sencillo, ligero y sobretodo confiable, ya que el código del script está hecho de un modo lo mas legible posible y utilizando herramientas de software libre muy bien auditadas.

Disponemos también de varias versiones con interfaz gráfica para escritorio, como por ejemplo *gtomb*. No puedo hablar de ella porque no la he probado, pero para aquellos que no les guste la terminal, es una buena solución. Recordaros que igual que en el [[https://ugeek.github.io/blog/post/2019-03-29-veracrypt-en-ubuntu-y-tu-raspberry-por-terminal.html][Post anterior de Veracrypt]], recomiendo el utilizar *alias* para abrir y cerrar las tumbas, solo por no tener que recordar los comando.


** Fuentes
- [[http://www.dyne.org/software/tomb/][Web de Tomb]]
- [[https://github.com/dyne/Tomb/wiki][Wiki de Tomb]]
* TODO Calculando con mi terminal
:PROPERTIES:
:TITLE: Calculando con mi terminal
:EXPORT_FILE_NAME: Calculando con mi terminal
:DESCRIPTION: Cuando comienzas a crear tus propios scripts, a veces te ves en la necesidad de hacer cálculos. Hoy os voy a explicar un par de comandos que podemos utilizar para hacer nuestros cálculos
:EXPORT_DATE: 2019-04-01 20:40
:CATEGORY: terminal
:TAG: bash,unix
:END:

Cuando comienzas a crear tus propios scripts, a veces te ves en la necesidad de hacer cálculos. Hoy os voy a explicar un par de comandos que podemos utilizar para hacer nuestros cálculos, *expr* (evalúa los argumentos como una expresión) y *calc* (Calculadora de precisión arbitraria).
 
*Expr* viene preinstalado en Ubuntu por defecto, cosa que no sucede con *calc*. Y os preguntareis: ¿Porque utilizar dos comandos? *expr* no utiliza decimales y para determinados casos nos puede ir bien, pero si queremos utilizar decimales, tendremos que echar mano de *calc*.

[[./images-blog/expr.jpg]]


Otro método de hacer cálculos sería con *bc*, pero lo dejo para otro Post porque *expr* y *calc* diría que es la versión de comandos para hacer cálculos seres humanos, escribiremos en la terminal igual que haríamos en una calculadora.


Con *expr* vamos a ejecutar operaciones aritméticas o de comparación. Vamos a ver como funciona:

=expr <número> <operador matemático> <número>=

** Suma
Hay que dejar un espacio en blanco entre los números y símbolo de *+*.

=expr 8 + 4=

Suma con números negativos:

=expr -30 + 47=

**  Resta

=expr 8 - 4=

** Multiplicación
Lleva la contrabarra *\* para escapar del asterísco. Es la única excepción respecto como lo haríamos con la calculadora:

=expr 8 \* 4=

** División

=expr 8 / 4=

** Porcentaje

=expr 10 % 100=

** Comparaciones
Otra cosa que nos permite *expr* es ejecutar comparaciones. Si la comparación es verdadera, nos devolverá *1*, si es falsa *0*.
Aquí también hay símbolos que llevan la contrabarra *\* para escapar.
#+BEGIN_SRC 
expr 10 =   7   # Igual
expr 10 !=  7   # No es igual
expr 10 \>  7   # Mayor que
expr 10 \<  7   # Menor que
expr 10 \<= 7   # Menor o igual
expr 10 \>= 7   # Mayor o igual
#+END_SRC

** Contando el número de letras
También podemos contar el número de letras que hay en una frase:

=expr length "hola mundo"=

O en un archivo de texto plano:

=expr length "$(cat mis_notas.txt)"=

** Manual
Hay muchas mas opciones. Lee en manual para conocerlas:

=man expr=

** Instalación de Calc
Calc no viene instalado por defecto en Ubuntu. Lo instalaremos así:

=sudo apt install apcalc=
** Suma
Suma con decimales:
#+BEGIN_SRC 
calc 12.5 + 21.4
	33.9
#+END_SRC
Aquí ya podemos sumar números negativos. Al poner el signo negativo, tiene que ir entre paréntesis.
#+BEGIN_SRC 
calc '(-30 + 47)'
	17
#+END_SRC
** Dos números negativos
#+BEGIN_SRC 
calc '(-30 - 47)'
	-77
#+END_SRC

** Multiplicación
En el caso de la multiplicación, *calc* no necesita *\* de escape:
#+BEGIN_SRC 
calc 30*2
	60
#+END_SRC
#+BEGIN_SRC 
calc '(-2 * 10)'
	-20
#+END_SRC
#+BEGIN_SRC 
calc 30\*2
	60
#+END_SRC

** División
#+BEGIN_SRC 
calc 200/10
	20
#+END_SRC

** Porcentaje
#+BEGIN_SRC 
calc 10%100
	10
#+END_SRC

** Manual 
Hay muchas mas en manual:

=man calc=

** Conclusión
Esto es tan solo unos ejemplos de estos comandos, pero podemos utilizarlo para contar letras entre líneas de archivos,... y muchas más cosas
Ahora ya solo queda llenar tus variables de números y comenzar ha hacer montones de cálculos.
* TODO Exportando bonito a html mi OrgMode y creando web estática
:PROPERTIES:
:TITLE: Exportando bonito a html mi OrgMode y creando web estática
:EXPORT_FILE_NAME: Exportando bonito a html mi OrgMode y creando web estatica
:DESCRIPTION: Hoy os traigo un paquete que exporta tus archivos orgmode a formato html de un modo más bonito y con más calidad 
:EXPORT_DATE: 2019-04-02 19:00
:CATEGORY: emacs
:TAG: html,github,gitlab
:END:

Emacs es espectacular, pero los usuarios que lo utilizan y crean paquetes, están al mismo nivel. Hoy os traigo un paquete que está disponible en los repositorios de [[https://melpa.org/][Melpa]] desarrollado por Brandon van Beekum, que exporta tus archivos orgmode a formato html de un modo más bonito y con más calidad. 

Por defecto emacs, exporta a html pero de un modo plano, osea código html puro y duro, necesitamos una plantilla css para que tenga formato y se vea mas bonito. Este paquete es como si llevara una plantilla css y javascript adjunta, creando la tabla de contenido del documento en la parte superior derecha, si utilizamos la versión de escritorio y en la parte inferior, si utilizamos un móvil. Esta tabla de contenido se va expandiendo conforme navegamos por nuestro orgmode en versión web.

[[./images-blog/ox-twbs.png]]


En la configuración, adjunto un ejemplo de como tener tus archivos orgmode en una carpeta y exportar los html a otra. Esto es interesante porque podríamos apuntar a esa carpeta como raíz de un servidor web, por ejemplo siguiendo el post del [[https://ugeek.github.io/blog/post/2019-03-25-monta-un-servidor-web-nginx-con-una-sola-linea-de-terminal-docker.html][Docker de Nginx]], haciendo accesible estas notas en formato web en nuestra red Local o via Internet.

Otra posibilidad sería publicarlo en las GitHub o GitLab Pages.

** Instalación
=M-x package-install [RET] ox-twbs [RET]=

Para exportar el archivo que estamos editando de orgmode a html con este paquete, ejecutaremos el siguiente comando en emacs:

=M-x org-twbs-export-to-html=

El archivo html resultante, estará en la misma carpeta donde está el archivo orgmode.
** Configuración 
Vamos a ver como exportar los html a otra carpeta que no sea la misma donde está el archivo orgmode. Copiaremos en nuestro archivo de configuración de emacs *init.el* o *.emacs*:

#+BEGIN_SRC 
(setq org-publish-project-alist
      '(("org-notes"
         :base-directory "~/org/"
         :publishing-directory "~/public_html/"
         :publishing-function org-twbs-publish-to-html
         :with-sub-superscript nil
         )))
#+END_SRC


En este archivo de configuración, utilizaremos las carpetas *~/org/* y *~/public_html/*. Los archivos orgmode los guardaremos en la carpeta  *~/org/* y cuando ejecutemos el comando dentro de emacs: =M-x org-publish-all= , será exportado en formato .html a la carpeta *~/public_html/*.

Previamente, crearemos las carpetas desde nuestra terminal:

=mkdir -p carpeta ~/org ~/public_html=

Podemos personalizar la carpeta que deseemos, modificando la ruta de las carpetas en el archivo de configuración.

** Sin tabla de contenido o índice, autor...
Si no queremos que aparezca tabla de contenido o índice, ni a pie de página el autor, fecha...  añadiremos al inicio de nuestro OrgMode:

[[./images-blog/ox-twbs2.png]]

#+BEGIN_SRC 
#+OPTIONS: html-postamble:nil toc:nil
#+END_SRC
** Cajetilla de código de color
Si queremos que salga la cajetilla de código de color negro, en el archivo orgmode añadiremos la siguiente línea. Como todo, es personalizable cambiando el color al que tu desees.
#+BEGIN_SRC 
#+HTML_HEAD_EXTRA: <style>pre { font-size: 13px; background-color: #000; color: #bbb; }</style>
#+END_SRC
** Conclusión
En el repositorio de GitHub de [[https://github.com/marsmining/ox-twbs][ox-twbs]] encontraras más información de este paquete. Encuentro que es un modo muy sencillo de tomar tus notas y acceder a ellas para consultar.

** Fuentes
- Fuente del paquete: https://github.com/marsmining/ox-twbs
- http://clubctrl.com/org/prog/howto.html
- http://clubctrl.com/org/prog/source.html
* TODO Montando carpetas del servidor, Raspberry,... en tu escritorio
:PROPERTIES:
:TITLE:  Montando carpetas del servidor, Raspberry,... en tu escritorio
:EXPORT_FILE_NAME:  Montando carpetas del servidor Raspberry en tu escritorio
:DESCRIPTION: SSHFS nos va a permitir montar una carpeta de un servidor, PC o Raspberry, en nuestro PC o portatíl y acceder a esta carpeta como si fuera una carpeta de nuestra PC o portátil 
:EXPORT_DATE: 2019-04-04 18:40
:CATEGORY: ssh
:TAG: servidor,
:END:

Hay momentos que estás conectado remotamente vía SSH a tu servidor, Raspberry... y aunque cada vez conoces mejor la terminal y te mueves con total soltura por los directorios 😜,  te gustaría acceder a esas carpetas de un modo gráfico para hacer un copia-pega, arrastrar un archivo,...  tener tu carpeta remota montada en local, como si fuera una carpeta de tu propio PC o Portátil.

[[./images-blog/sshfs.png]]

Esto nos lo va a permitir SSHFS, teniendo en la máquina remota un servidor SSH montado.

SSHFS nos va a permitir montar una carpeta de un servidor, PC o Raspberry, en nuestro PC o portatíl y acceder a esta carpeta como si fuera una carpeta de nuestra PC o portátil. Para ello tenemos que seguir los siguientes pásos:
- Instalaremos sshfs
- Crear una *carpeta vacía*, donde montaremos la carpeta remota
- Mediante una línea de terminal montaremos y desmontaremos la carpeta cuando lo deseemos
** Instalación en la máquina local
SSHFS, lo encontraremos en los repositorios de cualquier distro. En Ubuntu lo instalaremos así:

=sudo apt install sshfs=

** Creando la carpeta de montaje
En nuestro PC o portátil, crearemos una carpeta para el montaje, por ejemplo: *~/carpeta_montaje*

=mkdir -p ~/carpeta_montaje=

** Montar carpeta
Vamos a montar la *carpeta del servidor* que deseemos montar el local, en mi caso la carpeta llamada *carpeta_del_servidor*, en la carpeta de mi portátil que he creado llamada *carpeta_montaje*. 

Sustituye *usuario@192.168.1.100*, por el usuario e IP del servidor que te vas a conectar.

Ahora vamos a conectarnos con:

=sshfs usuario@192.168.1.100:/carpeta_del_servidor ~/carpeta_montaje=

En caso de haber cambiado el puerto del servidor SSH, por ejemplo al 5555, nos conectaríamos así:

=sshfs -p 5555 usuario@192.168.1.100:/carpeta_del_servidor ~/carpeta_montaje=

** Desmontar
Para desmontar la carpeta, introduciremos en la terminal *fusermount -u* seguido de la carpeta de montaje:

=fusermount -u ~/carpeta_montaje=
** Conclusión
Esta es la base de algunos de los siguientes Post donde vamos a utilizar SSHFS. Hacia tiempo que no lo utilizaba, pero la verdad es que aunque a veces puede ir un poco lento, es muy cómodo para gestionar tus archivos de un modo gráfico desde tu escritorio.
* TODO Montando una carpeta con todos mis servidores dlna
:PROPERTIES:
:TITLE:  Montando una carpeta con todos mis servidores dlna
:EXPORT_FILE_NAME:  Montando una carpeta con todos mis servidores dlna
:DESCRIPTION: Vamos a montar en una carpeta de nuestro PC, todos los servidores dlna que haya en nuestra red local y acceder a todo el contenido a través de nuestro explorador de archivos o terminal igual que lo haríamos con cualquier otra carpeta de nuestro PC 
:EXPORT_DATE: 2019-04-05 18:00
:CATEGORY: dlna
:TAG: servidor
:END:

[[./images-blog/dlna.png]]


Este es el cuarto Post de dlna, despues de:  [[https://ugeek.github.io/blog/post/2018-12-27-minidlna.html][monta tu servidor dlna]], [[https://ugeek.github.io/blog/post/2019-01-02-crear-listas-m3u-para-minidlna-o-vlc.html][Crear listas m3u para minidlna o vlc]] y [[https://ugeek.github.io/blog/post/2019-02-16-cliente-dlna-para-tu-escritorio.html][Cliente dlna para tu escritorio]]. En el último Post, donde os hablé de los clientes de escritorio, estoy seguro que llevaste decepción porque no podías utilizar con tu servidor *dlna* tu reproductor de música favorito. También la *no* posibilidad de poder descargar todas tus canciones o contenido multimedia, a través de tu servidor dlna para tenerlo en local. En el Post de hoy, vamos a solucionar todo esto montando en una carpeta de nuestro PC, *todos los servidores dlna* que haya en nuestra red local y acceder a todo el contenido a través de nuestro explorador de archivos o terminal, igual que lo haríamos con cualquier otra carpeta de nuestro PC.

Lo mejor de todo, es que es súper sencillo de instalar. Vamos a utilizar *djmount*

** Instalación de djmount
Podemos instalarlo desde los repositorios oficiales de cualquier distro con solo una línea de terminal:

=sudo apt install djmount=

Creamos la carpeta donde queramos montar todos los servidores *dlna* que hayan en nuestra red local. En mi caso voy a crear la carpeta *~/dlna*:

=mkdir ~/dlna=

** Montando y desmontando mi carpeta dlna
Para montar la carpeta donde estarán todos los servidores *dlna*, tan simple como:

=djmount ~/dlna=

Para desmontar:

=fusermount -u ~/dlna=
** Conclusión
Como ves, cada Post que voy publicando sobre *dlna*, te vas dando cuenta que montar el servidor multimedia *minidlna*, súper ligero y muy sencillo de configurar, no es ninguna tontería y vale muy mucho la pena. Es una forma de tener todo tu contenido multimedia centralizado y con aplicaciones como *djmount*, podemos acceder a todo el contenido, sin correr riesgo de borrar ningún archivo.
* TODO Atajos de Terminal 
:PROPERTIES:
:TITLE:  Atajos de Terminal
:EXPORT_FILE_NAME:  Atajos de Terminal
:DESCRIPTION: Aunque no lo parezca de salida y de muchísima pereza el aprenderse los atajos de teclado de la terminal, es algo verdaderamente muy útil
:EXPORT_DATE: 2019-04-06 0:40
:CATEGORY: terminal
:TAG: servidor
:END:

Aunque no lo parezca de salida y de muchísima pereza el aprenderse los atajos de teclado de la terminal, es algo verdaderamente muy útil. 

[[./images-blog/atajos.jpg]]


El truco para aprenderlos es leer todo lo que podemos hacer con atajos y cuando lo necesites, lee aquí el atajo y ejecutalo. En muy poco espacio de tiempo, estoy seguro que lo tendrás integrado y totalmente aprendido. 

Aprenderse los atajos de teclado para no utilizar el ratón, es de las cosas mas productivas que puedes hacer y no solo por el tiempo perdido en utilizar el ratón, sino que también influye en la fluidez a la hora de desarrollar aquello con lo que estás trabajando. 

No hay nada que te pare!!!

Comentaros que parte de estos comandos, son también compatibles con Emacs. Así que aprendemos por partida doble.

Los he agrupado según mi uso. Quizás lo que para mi es importante, para ti no lo es, pero aquí los tienes: 

** Importantes
- *Ctrl+a*: lleva el cursor al inicio de la línea
- *Ctrl+e*: lleva el cursor al final de la línea
- *Ctrl+k*: borra desde el cursor hasta el final de la línea
- *Ctrl+u*: borra desde el cursor hasta el inicio de la línea

** Importantes en el uso
- *Ctrl+l*: limpia la terminal
- *Ctrl+c*: termina el proceso que se esté ejecutando
- *Ctrl+z*: deja en segundo plano el proceso, para volver al proceso, introduce *fg*
- *Ctrl+r*: búsqueda de comandos usados anteriormente, escribiendo el inicio del comando 
- *Tab*: autocompleta comandos, rutas, directorios, archivos...

** Menos importantes en el uso
- *Ctrl+p*: último comando introducido
- *Ctrl+d*: sale de la terminal
- *Alt+.*:  escribe los últimos comandos a continuación de donde estemos
- *Ctrl+g*: Anular lo que estemos haciendo
** Intercambiar posiciones 
- *Ctrl+t*: intercambia la posición de los dos caracteres anteriores al cursor
- *Alt+t*: intercambia la posición de las dos palabras anteriores al cursor

** Mover cursor
- *Alt+f*:  salta a la siguiente palabra
- *Alt+b*:  salta a la anterior palabra
- *Ctrl+xx*: salta entre la posición actual y el inicio de la línea y viceversa
** Mas atajos de borrar
- *Ctrl+w*: borra la palabra anterior al cursor
- *Alt+d*: borra la palabra siguiente al cursor

** Copiar y Pegar
- *Ctrl+Shift+v*: pegar el texto del portapapeles en la terminal
- *Ctrl+Shift+c*: seleccionando el texto de la terminal, copiamos al portapapeles


** Abrir terminal
- *Ctrl+Alt+t*: La mayor parte de las terminales
- *F12*: Si utilizas Guake

* TODO Controla tu Raspberry, Servidor o PC desde Telegram 
:PROPERTIES:
:TITLE:  Controla tu Raspberry, Servidor o PC desde Telegram
:EXPORT_FILE_NAME:  Controla tu Raspberry Servidor o PC desde Telegram
:DESCRIPTION: Voy a explicarte como ejecutar un Bot de Telegram que te va a permitir el controlar la totalidad de tu Raspberry, Servidor o PC, remotamente desde Telegram
:EXPORT_DATE: 2019-04-11 17:45
:CATEGORY: telegram
:TAG: domotica
:IMAGE: ./images-blog/tocar_movil.jpg
:END:

Voy a explicarte como configurar un Bot de Telegram, que te va a permitir el controlar la totalidad de tu Raspberry, Servidor o PC, remotamente.

[[./images-blog/tocar_movil.jpg]]


Con este Bot no solo podrás conocer la temperatura, IP pública, ... Tal como te expliqué en el Post [[https://ugeek.github.io/blog/post/2019-03-14-crea-un-bot-de-telegram-con-bash-y-una-sola-linea-de-terminal.html][Crea un Bot de Telegram con Bash y una sola línea de Terminal]], sino que también podrás interactuar con él, iniciando o deteniendo servicios, mediante el GPIO podrás conectar luces, motores de persianas, puertas... ejecutar comandos que ejecutarías en la terminal, actualizar tu servidor... En definitiva, para todo aquello que dé tu imaginación. 

Lo mejor de todo, es que nos conectaremos a través de la API de Telegram, de modo que no necesitaremos utilizar ningún servicio tipo VPN. Nuestro Bot de Telegram, puede convertirse en un mando a distancia, teniendo el control total de todo lo que suceda en tu casa y lo mejor de todo, sin tener conocimientos de programación. Vamos a utilizar nuevamente Bash, como lenguaje de programación y añadiendo cuatro parámetros, vas a comenzar a controlarlo todo.  

He hecho un Fork de BaTBot en su última versión modificada por eliafino y lo he traducido al Castellano para el fácil comprensión.
BaTBot en la versión 1.4.3.4 lo encontrarás en mi [[https://github.com/uGeek/BaTbot][Repositorio en GitHub]].

** Instalación
Lo primero que vamos ha hacer es descargar BaTbot y clonar el repositorio, por ejemplo, en la carpeta de usuario de nuestra distro:
#+begin_src 
cd                                             # Esto nos llevará a la carpeta de usuario
git clone https://github.com/uGeek/BaTbot.git  # Clonamos el repositorio
cd ~/BaTbot/bin/                               # Accedemos a la carpeta ~/BaTbot/bin
#+end_src
Dentro de la carpeta *bin*, encontraremos el script del bot llamado *batbot*.

** Configurando BaTbot

Vamos a editar el archivo *batbot* y añadir las variables necesarias:

#+BEGIN_SRC 
nano ~/BaTbot/bin/batbot
#+END_SRC

La configuración va a ser muy simple. Necesitamos añadir las siguientes variables en el script:
- TELEGRAMTOKEN= <TOKEN>
- PERSONALID= <ID DEL USUARIO MAESTRO O MÁXIMO ADMINISTRADOR>
- BATBOTUSR= < RUTA DE LA CARPETA .batbot >

El TOKEN si recordáis, lo obteníamos a través de  [[https://t.me/BotFather][@BotFather]] y el ID, mediante el Bot [[https://t.me/ChannelIdBot][@ChannelIdBot]].

Si no recuerdas bien los pasos, te invito a leer el Post  [[https://ugeek.github.io/blog/post/2019-03-14-crea-un-bot-de-telegram-con-bash-y-una-sola-linea-de-terminal.html][Crea un Bot de Telegram con Bash y una sola línea de Terminal]], donde explico los pasos con mas detalle.

La ruta de la carpeta *.batbot*, hay que ponerla completa. Dentro de esta carpeta está la lista de usuarios que tendrán permisos para utilizar nuestro Bot.

Aquí tienes un ejemplo, con parámetros inventados, como quedaría:
#+begin_src 
# Ingrese el token BOT devuelto por BotFather                                                                                               
TELEGRAMTOKEN="780756347993:AAEhwrthws_Y9SOdPMl2NI2jM0oyQX0DMg"

# Ingrese el ID del usuario maestro, para notificaciones de uso                                                                               
PERSONALID="68690969"

# Ruta donde está nuestra carpeta .batbot en nuestro servidor, Raspberry,...                                       
BATBOTUSR="$HOME/BaTbot/.batbot"
#+end_src
Por defecto, BaTbot revisará cada 5 segundos si hay un nuevo mensaje. Esta opción la podemos personalizar poniendo el tiempo en segundos que deseemos:
#+begin_src 
# revisar nuevos mensajes cada X segundos:                                                                                                  
CHECKNEWMSG=5
#+end_src
** Añadiendo Nuestro ID al listado usuarios habilitados al uso del Bot
Ahora vamos a añadir nuestro ID de usuario, al listado de usuarios que tienen permisos para utilizar el Bot. Para ello, accederemos al archivo *allowed_users* :
#+begin_src 
nano ~/BaTbot/.batbot/allowed_users
#+end_src
Borraremos los números de ID que vienen de ejemplo y añadiremos nuestro ID o todos aquellos ID que tendrán permiso para poder utilizar el Bot.

Recuerda que si no ponemos nuestro ID en esta lista, no podremos interactuar con nuestro Bot.
** Ejecutar el Bot
Ahora volveremos a la carpeta *bin* y ejecutaremos *./batbot*
#+begin_src 
cd ~/BaTbot/bin/
./batbot
#+end_src
Ya puedes enviar mensajes al Bot. Escribe el comando */menu*, para que te muestre el menú.

En la terminal podremos ver todos los mensajes que recibe el Bot en tiempo real y que usuarios lo envían.

** Configurar un menú y añadir comandos
Esta parte del script, es donde podremos añadir comandos para que los ejecute nuestro Bot. 

Aquí hay algunos de ejemplo, pero si no los vas a utilizar, elimínalos de la lista. Deja solo aquellos comandos que utilizaras. 

Para recordar los comandos, crea el comando llamado por ejemplo */menu* y añade todos los comandos disponibles.

El Bot solo reconocerá como comando las palabras que empiezan por */*.

#+begin_src 
declare -A botcommands=(
        ["/start"]='exec userlist @USERID:@FIRSTNAME@LASTNAME'
        ["/myid"]='echo Tu ID es: @USERID'
        ["/myuser"]='echo Tu nombre de usuario es: @USERNAME'
        ["/ping ([a-zA-Z0-9]+)"]='echo Pong: @R1'
        ["/uptime"]="uptime"
        ["/add ([0-9]+)"]='exec admadduser @USERID @R1'
        ["/del ([0-9]+)"]='exec admdeluser @USERID @R1'
        ["/lista"]='exec admlistuser @USERID'
        ["/run (.*)"]="exec @R1"
        ["/docker_nginx_start"]="docker stop nginx"
        ["/docker_nginx_stop"]="docker start nginx"
        ["/menu"]="echo -e Bienvenido a Mi Bot\n/myid \n/myuser \n/uptime \n/run \n/ping \n\nDockers:\n/docker_nginx_start \n/docker_nginx_stop \n\n\n/menu")
#+end_src

En el chat del Bot, si ejecutamos el comando */menu*, nos contestará:

#+begin_src 
Bienvenido a Mi Bot
/myid 
/myuser 
/uptime 
/run 
/ping 

Dockers:
/docker_nginx_start 
/docker_nginx_stop 


/menu
#+end_src

Si envías el comando */run*, sería lo mismo que si estuvieras escribiendo en tu terminal

** Comandos simples 
Podemos ejecutar comandos simples como por ejemplo:

- Ejecutas */hello* y responde *Hola*
#+begin_src 
["/hello"]="echo Hola"    
#+end_src
- ¿Quieres saber el tiempo de actividad de tu servidor? No hay problema:
#+begin_src 
["/uptime"]="/usr/bin/uptime"
#+end_src
- ¿Queres conocer el espacio en disco libre a través de Telegram?
#+begin_src 
["/disks"]="/bin/df -h"
#+end_src

- Ejecutar script un externo:
#+begin_src 
["/auth ([a-zA-Z0-9]+)"]="/usr/local/bin/auth.sh @R1"
#+end_src
** Variables:

Puedes usar variables! por ejemplo:
#+begin_src 
["/hello"]="echo Hola @FIRSTNAME, encantado de conocerte :)"
#+end_src

** Lista de Varibales
- @USERID 	  (int) ID del usuario que envió el comando activado
- @USERNAME 	(string) Nombre de usuario de usuario en Telegram
- @FIRSTNAME	(string) El primer nombre del usuario
- @LASTNAME	  (string) El apellido del usuario
- @CHATID 	  (int)  El ID de chat donde el usuario envió un comando
- @MSGID 		  (int) ID del mensaje que activó un comando
- @TEXT		    (string) El texto completo de un mensaje recibido
- @FROMID		  (int) ID del usuario que envió un mensaje

Regex group extract
- @R1 		Contenido del primer grupo (.*)
- @R2 		Contenido del segundo grupo (.*)
- @R3 		Contenido del tercero grupo (.*)

** Comando con expresiones regulares
También puedes configurar un comando con argumentos, por ejemplo: "/ping 1234". Todos los argumentos pueden ser expresiones regulares, por ejemplo:
#+begin_src 
["/ping ([0-9]+)"]="echo Pong: @R1"

["/blacklist ([0-9]+\.[0-9]+\.[0-9]+\.[0-9]+)"]="/sbin/iptables -A INPUT -s @R1 -j DROP"

["/whois ([a-zA-Z0-9\.\-]+)"]="/usr/bin/whois @R1"

["/host ([a-zA-Z0-9\.\-]+)"]="/usr/bin/host @R1"
#+end_src

** Enviar mensaje
Cuando BaTbot se está ejecutando, puedes enviar un mensaje utilizando el ID del usuario, usando el comando *.msg* directamente en la consola. 
#+begin_src 
.msg <ID> <MENSAJE>
#+end_src
Por ejemplo:
#+begin_src 
[chat 110440209, from  110440209] <theMiddle - Andrea Menin> hi bot :)
.msg 110440209 No utilices más mi Bot!!!
#+end_src

** Conclusiones
Hay muchas mas opciones que podemos configurar desde el propio Bot, como añadir usuarios al listado desde el propio chat del Bot, etc... La verdad es que no he tenido suficiente tiempo de hacer todas las pruebas. El Objetivo de Gestionar nuestro servidor remotamente, cumple perfectamente. 

Si quieres hacer pruebas, la carpeta que hay en el repositorio *.batbot*, donde esta el archivo *allowed_users*, tendría que estar en al carpeta =$HOME/.batbot=. Yo en el Post lo he dejado en la misma carpeta igual que el repositorio, para tener todos las carpetas en el mismo lugar.
